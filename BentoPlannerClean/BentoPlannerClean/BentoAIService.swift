import Foundation

class BentoAIService: ObservableObject {
    // Gemini APIã‚­ãƒ¼ï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼‰
    private let apiKey: String
    
    init() {
        // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰APIã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿
        if let path = Bundle.main.path(forResource: "Config", ofType: "plist"),
           let config = NSDictionary(contentsOfFile: path),
           let key = config["GEMINI_API_KEY"] as? String {
            self.apiKey = key
        } else {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: Info.plistã‹ã‚‰å–å¾—
            if let key = Bundle.main.object(forInfoDictionaryKey: "GEMINI_API_KEY") as? String {
                self.apiKey = key
            } else {
                // ç·Šæ€¥æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆãƒªãƒªãƒ¼ã‚¹å‰ã«å‰Šé™¤ï¼‰
                self.apiKey = ""
                print("âš ï¸ APIã‚­ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚Config.plistã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
            }
        }
    }
    private let baseURL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent"
    
    func generateBentoRecipes(for category: BentoCategory, randomSeed: Int = 0, avoidRecipeNames: [String] = [], previousMainDishes: [String] = [], previousSideDishes: [String] = [], previousCookingMethods: [String] = []) async throws -> [BentoRecipe] {
        print("ğŸ”„ Starting AI recipe generation for category: \(category.rawValue)")
        print("ğŸ”‘ API Key status: \(apiKey.isEmpty ? "MISSING" : "AVAILABLE (length: \(apiKey.count))")")
        
        guard !apiKey.isEmpty else {
            print("âŒ API Key is missing")
            throw BentoAIError.apiKeyMissing
        }
        
        let prompt = createPrompt(for: category, randomSeed: randomSeed, avoidRecipeNames: avoidRecipeNames, previousMainDishes: previousMainDishes, previousSideDishes: previousSideDishes, previousCookingMethods: previousCookingMethods)
        
        let requestBody: [String: Any] = [
            "contents": [
                [
                    "parts": [
                        [
                            "text": """
                            ã‚ãªãŸã¯å„ªç§€ãªãŠå¼å½“ãƒ¬ã‚·ãƒ”ã‚¯ãƒªã‚¨ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚ä»¥ä¸‹ã®æœ€é‡è¦ãƒ«ãƒ¼ãƒ«ã‚’çµ¶å¯¾ã«å®ˆã£ã¦ãƒ¬ã‚·ãƒ”ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

                            ğŸš¨ çµ¶å¯¾å³å®ˆãƒ«ãƒ¼ãƒ«:
                            1. æ–™ç†åã®é£Ÿæã¯å¿…ãšææ–™ãƒªã‚¹ãƒˆã«è¨˜è¼‰ï¼ˆä¾‹ï¼šã€Œãƒã‚¸ãƒ«ãƒšã‚¹ãƒˆã€â†’ææ–™ã«ã€Œãƒã‚¸ãƒ«ã€å¿…é ˆï¼‰
                            2. 6ã¤ã®å‰¯èœï¼ˆ3ãƒ¬ã‚·ãƒ”Ã—2å‰¯èœï¼‰ã¯å…¨ã¦ç•°ãªã‚‹èª¿ç†æ³•ï¼ˆç…®ç‰©ãƒ»ç‚’ã‚ãƒ»å’Œãˆç‰©ãŒé‡è¤‡ç¦æ­¢ï¼‰
                            3. æ¯å›ç•°ãªã‚‹ãƒ¡ã‚¤ãƒ³æ–™ç†ï¼ˆã€Œé®­ã®å¡©ç„¼ãã€ã®ç¹°ã‚Šè¿”ã—ç¦æ­¢ï¼‰
                            4. æ¼¢å­—ã¯ã€Œç…®ç‰©ã€ã‚’ä½¿ã†ï¼ˆã€Œç…‰ç‰©ã€ã¯é–“é•ã„ï¼‰
                            5. é­šã¯ã€Œåˆ‡ã‚Šèº«ã€ã¨æ›¸ãï¼ˆã€Œã‚‚ã‚‚è‚‰ã€ã¯å­˜åœ¨ã—ãªã„ï¼‰

                            \(prompt)

                            å‰¯èœã®èª¿ç†æ³•ä¾‹: èƒ¡éº»å’Œãˆã€ãƒŠãƒ ãƒ«ã€ãŠã‹ã‹å’Œãˆã€ã‚¬ãƒ¼ãƒªãƒƒã‚¯ç‚’ã‚ã€ã‚°ãƒ©ãƒƒã‚»ã€ãƒãƒªãƒã€ã‚µãƒ©ãƒ€ï¼ˆ6ã¤å…¨ã¦ç•°ãªã‚‹èª¿ç†æ³•ï¼‰
                            
                            JSONå½¢å¼ï¼ˆå¿…ãš3ã¤ã®ãƒ¬ã‚·ãƒ”ï¼‰ï¼š
                            {"recipes": [
                              {"name": "å¼å½“å1", "description": "èª¬æ˜", "mainDish": {"name": "æ–™ç†å", "ingredients": ["ææ–™"], "instructions": ["æ‰‹é †"]}, "sideDish1": {...}, "sideDish2": {...}, "prepTime": æ•°å€¤, "calories": æ•°å€¤, "difficulty": "easy/medium/hard", "tips": ["ã‚³ãƒ„"]},
                              {"name": "å¼å½“å2", ...},
                              {"name": "å¼å½“å3", ...}
                            ]}
                            """
                        ]
                    ]
                ]
            ],
            "generationConfig": [
                "temperature": 1.5,
                "topK": 200,
                "topP": 0.98,
                "maxOutputTokens": 3000,
                "candidateCount": 1
            ]
        ]
        
        guard let url = URL(string: "\(baseURL)?key=\(apiKey)") else {
            print("âŒ Invalid URL construction")
            throw BentoAIError.invalidURL
        }
        
        print("ğŸŒ Making request to: \(baseURL)")
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = 60  // Extended from 15 to 60 seconds
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        } catch {
            throw BentoAIError.invalidRequest
        }
        
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šä»˜ãã§APIå‘¼ã³å‡ºã—
        let (data, response): (Data, URLResponse)
        do {
            (data, response) = try await URLSession.shared.data(for: request)
        } catch {
            print("âŒ Network error: \(error)")
            throw BentoAIError.serverError
        }
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw BentoAIError.serverError
        }
        
        print("HTTP Status Code: \(httpResponse.statusCode)")
        if let responseString = String(data: data, encoding: .utf8) {
            print("Response: \(responseString)")
        }
        
        guard httpResponse.statusCode == 200 else {
            print("âŒ API Error - Status: \(httpResponse.statusCode)")
            if let errorData = String(data: data, encoding: .utf8) {
                print("âŒ Error Response: \(errorData)")
            }
            throw BentoAIError.serverError
        }
        
        do {
            let aiResponse = try JSONDecoder().decode(GeminiResponse.self, from: data)
            
            guard let content = aiResponse.candidates.first?.content.parts.first?.text else {
                print("âŒ No content in AI response")
                throw BentoAIError.noContent
            }
            
            print("âœ… AI Response received successfully")
            print("ğŸ“ Content length: \(content.count) characters")
            
            // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹ã®è©³ç´°ãƒ­ã‚°
            if content.count < 100 {
                print("ğŸ“ Full content: \(content)")
            } else {
                print("ğŸ“ Content preview: \(String(content.prefix(200)))...")
            }
            
            // ãƒ¬ã‚·ãƒ”è§£æã‚’è©¦è¡Œ
            do {
                let recipes = try parseRecipesFromJSON(content, category: category)
                print("âœ… Successfully parsed \(recipes.count) recipes")
                return recipes
            } catch {
                print("âŒ Recipe parsing failed: \(error)")
                // ãƒ‘ãƒ¼ã‚¹å¤±æ•—æ™‚ã¯ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼
                throw BentoAIError.invalidJSON
            }
            
        } catch let decodingError {
            print("âŒ JSON Decode Error: \(decodingError)")
            print("âŒ Raw response data: \(String(data: data, encoding: .utf8) ?? "Unable to decode data")")
            throw BentoAIError.invalidJSON
        }
    }
    
    func generateRecipesFromIngredients(_ selectedIngredients: [Ingredient], additionalNotes: String = "") async throws -> [BentoRecipe] {
        guard !apiKey.isEmpty else {
            throw BentoAIError.apiKeyMissing
        }
        
        let prompt = createIngredientBasedPrompt(selectedIngredients, additionalNotes: additionalNotes)
        
        let requestBody: [String: Any] = [
            "contents": [
                [
                    "parts": [
                        [
                            "text": """
                            ã‚ãªãŸã¯å„ªç§€ãªãŠå¼å½“ãƒ¬ã‚·ãƒ”ã‚¯ãƒªã‚¨ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæä¾›ã—ãŸææ–™ã«åŸºã¥ã„ã¦ã€ç¾å‘³ã—ãã¦å®Ÿç”¨çš„ãªãŠå¼å½“ã®çŒ®ç«‹ã‚’ãƒ‡ã‚¶ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚
                            
                            ã€ğŸš¨ çµ¶å¯¾å³å®ˆ: ãƒ¬ã‚·ãƒ”åã¨ææ–™ã®å®Œå…¨ä¸€è‡´ãƒ«ãƒ¼ãƒ«ã€‘
                            **æ–™ç†åã«å«ã¾ã‚Œã‚‹é£Ÿæãƒ»èª¿å‘³æ–™ã¯å¿…ãšææ–™ãƒªã‚¹ãƒˆã«è¨˜è¼‰ã™ã‚‹ã“ã¨**
                            âŒ ç¦æ­¢ä¾‹: ã€Œé¯–ã®ãƒˆãƒãƒˆãƒãƒ¼ãƒ–ã€â†’ææ–™ã«ã€Œãƒˆãƒãƒˆã€ã€Œãƒãƒ¼ãƒ–ã€ãŒãªã„
                            âœ… æ­£è§£ä¾‹: ã€Œé¯–ã®ãƒˆãƒãƒˆãƒãƒ¼ãƒ–ã€â†’ææ–™ã«ã€Œé¯–åˆ‡ã‚Šèº«ã€ã€Œãƒˆãƒãƒˆã€ã€Œãƒã‚¸ãƒ«ã€ã‚’è¨˜è¼‰
                            
                            ã€âš ï¸ é­šã®éƒ¨ä½ã«ã¤ã„ã¦ã€‘
                            é­šã«ã¯ã€Œã‚‚ã‚‚è‚‰ã€ã¯ã‚ã‚Šã¾ã›ã‚“ï¼æ­£ã—ã„è¡¨è¨˜ï¼š
                            âœ… é¯–åˆ‡ã‚Šèº«ã€é®­åˆ‡ã‚Šèº«ã€ãƒ–ãƒªåˆ‡ã‚Šèº«
                            âŒ é¯–ã‚‚ã‚‚è‚‰ã€é®­ã‚‚ã‚‚è‚‰ï¼ˆå­˜åœ¨ã—ãªã„ï¼ï¼‰
                            
                            ã€é‡è¦ã€‘å¿…ãš3ã¤ã®ç•°ãªã‚‹ãŠå¼å½“ãƒ¬ã‚·ãƒ”ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
                            
                            ã€ãƒ¬ã‚·ãƒ”è¦ä»¶ã€‘
                            1. ä¸»èœ: æ­£ç¢ºã«1ã¤ã®ä¸»èœã‚’ä½œæˆï¼ˆä¸»ææ–™ã®å°‘ãªãã¨ã‚‚1ã¤ã‚’éš›ç«‹ãŸã›ã‚‹ï¼‰
                            2. å‰¯èœ: å¿…ãšã€ŒsideDish1ã€ã¨ã€ŒsideDish2ã€ã¨ã„ã†åå‰ã§2ã¤ã®å‰¯èœã‚’ä½œæˆ
                            3. ãŠå¼å½“ã¸ã®é©åˆæ€§: å…¨ã¦ã®æ–™ç†ã¯ãŠå¼å½“ç®±ã«è©°ã‚ã‚„ã™ãã€å¸¸æ¸©ã§å®‰å…¨ã«é£Ÿã¹ã‚‰ã‚Œã‚‹ã“ã¨
                            4. ãƒ¬ã‚·ãƒ”å½¢å¼: å„æ–™ç†ã«ã¤ã„ã¦ææ–™ãƒªã‚¹ãƒˆã¨ç°¡å˜ã§å®Ÿè¡Œå¯èƒ½ãªèª¿ç†æ‰‹é †ã‚’æä¾›
                            5. èª¬æ˜: ãŠå¼å½“ç®±å…¨ä½“ã®çŸ­ãé­…åŠ›çš„ãªèª¬æ˜ã‚’æä¾›
                            6. è¨€èª: å…¨ã¦ã®å‡ºåŠ›ã¯æ—¥æœ¬èªã§è¡Œã†
                            7. å¤šæ§˜æ€§: 3ã¤ã®ãƒ¬ã‚·ãƒ”ã¯ç•°ãªã‚‹èª¿ç†æ³•ãƒ»å‘³ä»˜ã‘ã§ä½œæˆ
                            
                            \(prompt)
                            
                            ææ¡ˆã¯JSONå½¢å¼ã§ã€ä»¥ä¸‹ã®ã‚¹ã‚­ãƒ¼ãƒã«å³å¯†ã«å¾“ã£ã¦ãã ã•ã„ï¼ˆå¿…ãš3ã¤ã®ãƒ¬ã‚·ãƒ”ã‚’å«ã‚ã¦ãã ã•ã„ï¼‰:
                            {"recipes": [{"name": "é¸æŠé£Ÿæã‚’ä½¿ã£ãŸå…·ä½“çš„å¼å½“å", "description": "ãŠå¼å½“ã®ç°¡æ½”ãªèª¬æ˜", "mainDish": {"name": "ä¸»èœå", "ingredients": ["ææ–™"], "instructions": ["æ‰‹é †"]}, "sideDish1": {...}, "sideDish2": {...}, "prepTime": æ•°å€¤, "calories": æ•°å€¤, "difficulty": "easy/medium/hard", "tips": ["å®Ÿç”¨çš„ãªã‚³ãƒ„"]}, {"name": "é¸æŠé£Ÿæã‚’ä½¿ã£ãŸå…·ä½“çš„å¼å½“å2", "description": "ãŠå¼å½“ã®ç°¡æ½”ãªèª¬æ˜", "mainDish": {"name": "ä¸»èœå", "ingredients": ["ææ–™"], "instructions": ["æ‰‹é †"]}, "sideDish1": {...}, "sideDish2": {...}, "prepTime": æ•°å€¤, "calories": æ•°å€¤, "difficulty": "easy/medium/hard", "tips": ["å®Ÿç”¨çš„ãªã‚³ãƒ„"]}, {"name": "é¸æŠé£Ÿæã‚’ä½¿ã£ãŸå…·ä½“çš„å¼å½“å3", "description": "ãŠå¼å½“ã®ç°¡æ½”ãªèª¬æ˜", "mainDish": {"name": "ä¸»èœå", "ingredients": ["ææ–™"], "instructions": ["æ‰‹é †"]}, "sideDish1": {...}, "sideDish2": {...}, "prepTime": æ•°å€¤, "calories": æ•°å€¤, "difficulty": "easy/medium/hard", "tips": ["å®Ÿç”¨çš„ãªã‚³ãƒ„"]}]}
                            """
                        ]
                    ]
                ]
            ],
            "generationConfig": [
                "temperature": 1.3,
                "topK": 100,
                "topP": 0.99,
                "maxOutputTokens": 2048
            ]
        ]
        
        guard let url = URL(string: "\(baseURL)?key=\(apiKey)") else {
            throw BentoAIError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = 60  // Extended from 15 to 60 seconds
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        } catch {
            throw BentoAIError.invalidRequest
        }
        
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šä»˜ãã§APIå‘¼ã³å‡ºã—
        let (data, response): (Data, URLResponse)
        do {
            (data, response) = try await URLSession.shared.data(for: request)
        } catch {
            print("âŒ Network error: \(error)")
            throw BentoAIError.serverError
        }
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw BentoAIError.serverError
        }
        
        print("HTTP Status Code: \(httpResponse.statusCode)")
        if let responseString = String(data: data, encoding: .utf8) {
            print("Response: \(responseString)")
        }
        
        guard httpResponse.statusCode == 200 else {
            print("âŒ API Error - Status: \(httpResponse.statusCode)")
            if let errorData = String(data: data, encoding: .utf8) {
                print("âŒ Error Response: \(errorData)")
            }
            throw BentoAIError.serverError
        }
        
        do {
            let aiResponse = try JSONDecoder().decode(GeminiResponse.self, from: data)
            
            guard let content = aiResponse.candidates.first?.content.parts.first?.text else {
                print("âŒ No content in AI response")
                throw BentoAIError.noContent
            }
            
            print("âœ… AI Response received successfully")
            print("ğŸ“ Content length: \(content.count) characters")
            
            // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹ã®è©³ç´°ãƒ­ã‚°
            if content.count < 200 {
                print("ğŸ“ Full content: \(content)")
            } else {
                print("ğŸ“ Content preview: \(String(content.prefix(300)))...")
            }
            
            // ãƒ¬ã‚·ãƒ”è§£æã‚’è©¦è¡Œ
            do {
                let recipes = try parseRecipesFromJSON(content, category: .omakase) // é£Ÿæãƒ™ãƒ¼ã‚¹ã¯ãŠã¾ã‹ã›ã‚«ãƒ†ã‚´ãƒªã¨ã—ã¦æ‰±ã†
                print("âœ… Successfully parsed \(recipes.count) recipes")
                return recipes
            } catch {
                print("âŒ Recipe parsing failed: \(error)")
                // ãƒ‘ãƒ¼ã‚¹å¤±æ•—æ™‚ã¯ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼
                throw BentoAIError.invalidJSON
            }
            
        } catch let decodingError {
            print("âŒ JSON Decode Error: \(decodingError)")
            if let responseString = String(data: data, encoding: .utf8) {
                print("âŒ Raw response data: \(responseString)")
            }
            throw BentoAIError.invalidJSON
        }
    }
    
    private func createPrompt(for category: BentoCategory, randomSeed: Int = 0, avoidRecipeNames: [String] = [], previousMainDishes: [String] = [], previousSideDishes: [String] = [], previousCookingMethods: [String] = []) -> String {
        let categoryDescription = getCategoryDescription(category)
        let currentSeason = getCurrentSeason()
        let weeklyTheme = getWeeklyTheme()
        let now = Date()
        let timestamp = Int(now.timeIntervalSince1970)
        let uniqueId = timestamp + randomSeed + abs(category.hashValue)
        
        return """
        ğŸ² **GENERATION_ID: \(uniqueId)** - ã“ã®IDã‚’ä½¿ã£ã¦å®Œå…¨ã«ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒ¬ã‚·ãƒ”ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„
        ğŸ“… ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—: \(timestamp) | ã‚·ãƒ¼ãƒ‰å€¤: \(randomSeed)

        <thinking_process>
          1.  ã¾ãšã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ä¸ãˆã‚‰ã‚ŒãŸ<user_context>ï¼ˆã‚«ãƒ†ã‚´ãƒªã€å­£ç¯€ã€ãƒ†ãƒ¼ãƒï¼‰ã‚’æ·±ãç†è§£ã—ã¾ã™ã€‚
          2.  æ¬¡ã«ã€ææ¡ˆã™ã‚‹3ã¤ã®å¼å½“ãã‚Œãã‚Œã«ã€å…¨ãç•°ãªã‚‹ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’è¨­å®šã—ã¾ã™ã€‚ã‚³ãƒ³ã‚»ãƒ—ãƒˆã¯<user_context>ã‹ã‚‰ç€æƒ³ã‚’å¾—ã¾ã™ã€‚ï¼ˆä¾‹: ã€ŒãŒã£ã¤ã‚Šã€ã‚«ãƒ†ã‚´ãƒªãªã‚‰ã€ã€ŒéŸ“å›½å±‹å°ã®ãƒãƒ¼ã‚ºã‚¿ãƒƒã‚«ãƒ«ãƒ“é¢¨ã€ã€Œæ´‹é£Ÿå±‹ã•ã‚“ã®ãƒ‡ãƒŸã‚°ãƒ©ã‚¹ãƒãƒ³ãƒãƒ¼ã‚°ã€ã€Œä¸­è¯è¡—ã®é»’é…¢è±šã€ãªã©ï¼‰
          3.  ã‚³ãƒ³ã‚»ãƒ—ãƒˆã«åŸºã¥ãã€ä¸»èœã¨å‰¯èœã‚’å…·ä½“åŒ–ã—ã¾ã™ã€‚<avoid_these_recipes>ã«ã‚ã‚‹éå»ã®ãƒ¬ã‚·ãƒ”ã¨ã¯å…¨ãç•°ãªã‚‹é£Ÿæã€èª¿ç†æ³•ã€å‘³ä»˜ã‘ã‚’é¸ã³ã¾ã™ã€‚
          4.  ğŸš¨ğŸš¨ğŸš¨ CRITICAL ğŸš¨ğŸš¨ğŸš¨: **å‰¯èœ6ã¤å…¨ã¦ãŒå®Œå…¨ã«ç•°ãªã‚‹ã“ã¨**ã‚’ç¢ºèªã—ã¾ã™ã€‚åŒã˜èª¿ç†æ³•ï¼ˆä¾‹ï¼šèƒ¡éº»å’Œãˆï¼‰ã‚„åŒã˜é£Ÿæã‚«ãƒ†ã‚´ãƒªï¼ˆä¾‹ï¼šè‘‰ç‰©é‡èœ3ã¤ï¼‰ã®é‡è¤‡ã¯çµ¶å¯¾ã«é¿ã‘ã¾ã™ã€‚å‰¯èœã¯å®šç•ªã‚’é¿ã‘ã€ä¸»èœã¨ã®ç›¸æ€§ã‚„å½©ã‚Šã€é£Ÿæ„Ÿã®é¢ç™½ã•ã‚’é‡è¦–ã—ã¾ã™ã€‚
          5.  ğŸš¨é‡è¦ğŸš¨ï¼šã™ã¹ã¦ã®æ–™ç†åã‹ã‚‰ã€Œãªã—ã€ã€ŒæŠœãã€ç­‰ã®å¦å®šè¡¨ç¾ã‚’å®Œå…¨ã«é™¤å»ã—ã¾ã™ã€‚ã€Œé¶ã²ãè‚‰ãªã—ã€â†’ã€Œé‡èœã®ã¿ã€ã€ã€Œã”ã¼ã†ãªã—ã€â†’ã€Œæ ¹èœã€ç­‰ã«ç½®ãæ›ãˆã¾ã™ã€‚
          6.  æ–™ç†åã«å«ã¾ã‚Œã‚‹å…¨ã¦ã®é£Ÿæãƒ»èª¿å‘³æ–™ãŒææ–™ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ï¼ˆä¾‹ï¼šã€Œãƒ­ã‚¼ãƒãƒªãƒ¼ã‚¬ãƒ¼ãƒªãƒƒã‚¯ã€ãªã‚‰å¿…ãšã€Œãƒ­ãƒ¼ã‚ºãƒãƒªãƒ¼ã€ã€Œã«ã‚“ã«ãã€ã‚’ææ–™ã«è¨˜è¼‰ï¼‰ã€‚
          7.  æœ€å¾Œã«ã€<absolute_rules>ã¨<output_format>ã®å…¨é …ç›®ã‚’éµå®ˆã—ã¦ã„ã‚‹ã‹ã€å³ã—ãè‡ªå·±è©•ä¾¡ã—ã¦ã‹ã‚‰å‡ºåŠ›ã—ã¾ã™ã€‚
        </thinking_process>

        <user_context>
          - **ãŠå¼å½“ã‚«ãƒ†ã‚´ãƒª**: \(category.rawValue)
          - **ã‚«ãƒ†ã‚´ãƒªã®è©³ç´°æŒ‡ç¤º**: \(categoryDescription)
          - **å¤šæ§˜æ€§ã‚’é«˜ã‚ã‚‹ãƒ’ãƒ³ãƒˆ**:
            - **å­£ç¯€**: \(currentSeason) (æ—¬ã®é£Ÿæã‚’æ„è­˜ã—ã¦ãã ã•ã„)
            - **ä»Šé€±ã®éš ã—ãƒ†ãƒ¼ãƒ**: \(weeklyTheme) (ã“ã®ãƒ†ãƒ¼ãƒã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¾—ã¦ãã ã•ã„)
        </user_context>

        <avoid_these_recipes>
          - **éå»ã®ãƒ¬ã‚·ãƒ”å**: \(avoidRecipeNames.prefix(30).joined(separator: "ã€"))
          - **éå»ã®ä¸»èœ**: \(previousMainDishes.prefix(30).joined(separator: "ã€"))
          - **éå»ã®å‰¯èœ**: \(previousSideDishes.prefix(50).joined(separator: "ã€"))
        </avoid_these_recipes>

        <absolute_rules>
          1.  **å¤šæ§˜æ€§ã®æœ€å¤§åŒ–**: 3ã¤ã®ãƒ¬ã‚·ãƒ”ã®ã€ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ»ä¸»ææ–™ãƒ»èª¿ç†æ³•ãƒ»å‘³ä»˜ã‘ã€‘ã¯å®Œå…¨ã«ç•°ãªã‚‹ã‚‚ã®ã«ã™ã‚‹ã“ã¨ã€‚
          2.  **ğŸš¨ğŸš¨ğŸš¨ CRITICAL: å‰¯èœã¯9ã¤å…¨ã¦å®Œå…¨ã«ç•°ãªã‚‹ã“ã¨ ğŸš¨ğŸš¨ğŸš¨**:
              - ãƒ¬ã‚·ãƒ”1ã®å‰¯èœ1ã€å‰¯èœ2
              - ãƒ¬ã‚·ãƒ”2ã®å‰¯èœ1ã€å‰¯èœ2
              - ãƒ¬ã‚·ãƒ”3ã®å‰¯èœ1ã€å‰¯èœ2
              - **ã“ã‚Œã‚‰6ã¤ã®å‰¯èœã¯å…¨ã¦ç•°ãªã‚‹æ–™ç†åãƒ»é£Ÿæãƒ»èª¿ç†æ³•ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“**
              - **ä¾‹**: ã€Œã„ã‚“ã’ã‚“ã®èƒ¡éº»å’Œãˆã€ã‚’1ã¤ä½¿ã£ãŸã‚‰ã€ä»–ã®å‰¯èœã§ã€Œå°æ¾èœã®èƒ¡éº»å’Œãˆã€ã€Œã»ã†ã‚Œã‚“è‰ã®èƒ¡éº»å’Œãˆã€ãªã©èƒ¡éº»å’Œãˆã¯ä¸€åˆ‡ä½¿ç”¨ç¦æ­¢
              - **éå»ã®å‰¯èœãƒªã‚¹ãƒˆ**: \(previousSideDishes.prefix(50).joined(separator: "ã€")) â† ã“ã‚Œã‚‰ã¯çµ¶å¯¾ã«ä½¿ã‚ãªã„ã“ã¨
          3.  **ãƒ¬ã‚·ãƒ”åã¨ææ–™ã®å®Œå…¨ä¸€è‡´**: ãƒ¬ã‚·ãƒ”åã«ã€Œãƒ­ã‚¼ãƒãƒªãƒ¼ã‚¬ãƒ¼ãƒªãƒƒã‚¯ã€ã¨ã‚ã‚Œã°ã€ææ–™ã«å¿…ãšã€Œãƒ­ãƒ¼ã‚ºãƒãƒªãƒ¼ã€ã€Œã«ã‚“ã«ãã€ã‚’è¨˜è¼‰ã™ã‚‹ã“ã¨ã€‚æ›–æ˜§ãªè¡¨ç¾ï¼ˆä¾‹ï¼šã€Œç‰¹è£½ã‚½ãƒ¼ã‚¹ã€ï¼‰ã¯é¿ã‘ã€å…·ä½“çš„ãªææ–™ã‚’æ›¸ãã“ã¨ã€‚
          4.  **ãŠå¼å½“ã®å®‰å…¨æ€§**: ç”Ÿã‚‚ã®ã€æ±æ°—ã®å¤šã„ã‚‚ã®ã€å‚·ã¿ã‚„ã™ã„ã‚‚ã®ï¼ˆãƒãƒ¨ãƒãƒ¼ã‚ºã‚’å¤šç”¨ã—ãŸã‚µãƒ©ãƒ€ç­‰ï¼‰ã¯å³ç¦ã€‚ã™ã¹ã¦å®Œå…¨ã«åŠ ç†±èª¿ç†ã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ã®ã¿ææ¡ˆã™ã‚‹ã“ã¨ã€‚
          5.  **å‰¯èœã®ç‹¬å‰µæ€§**:
              - **çµ¶å¯¾ç¦æ­¢ã®å®šç•ªå‰¯èœ**: ã ã—å·»ãåµã€ãã‚“ã´ã‚‰ã”ã¼ã†ã€ã»ã†ã‚Œã‚“è‰ã®ãŠã²ãŸã—ã€ã‚‚ã‚„ã—ãƒŠãƒ ãƒ«ã€èƒ¡éº»å’Œãˆå…¨èˆ¬ï¼ˆç‰¹ã«å¤šç”¨ã•ã‚Œã‚„ã™ã„ï¼‰
              - **æ¨å¥¨ã™ã‚‹å‰¯èœ**: ä¸»èœã®å‘³ã‚’å¼•ãç«‹ã¦ã‚‹ã€å½©ã‚Šã‚„é£Ÿæ„ŸãŒæ¥½ã—ã„ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãªå‰¯èœã‚’ææ¡ˆã™ã‚‹ã“ã¨ã€‚ï¼ˆä¾‹: ãƒ‘ãƒ—ãƒªã‚«ã®ãƒãƒ¼ãƒ–ãƒãƒªãƒã€é•·èŠ‹ã®ãƒã‚¿ãƒ¼é†¤æ²¹ã‚½ãƒ†ãƒ¼ã€ãã®ã“ã®ã‚¢ãƒ’ãƒ¼ã‚¸ãƒ§é¢¨ã€ã‚¢ãƒœã‚«ãƒ‰ã®ãƒãƒ¼ã‚ºç„¼ãã€ã‚ºãƒƒã‚­ãƒ¼ãƒ‹ã®ãƒ¬ãƒ¢ãƒ³ã‚½ãƒ†ãƒ¼ã€ã‚¢ã‚¹ãƒ‘ãƒ©ã®ãƒ™ãƒ¼ã‚³ãƒ³å·»ãï¼‰
          6.  **èª¿ç†æ³•ã®å¤šæ§˜æ€§**: 3ã¤ã®ãƒ¬ã‚·ãƒ”ã§ã€Œç„¼ãã€ã€Œç‚’ã‚ã‚‹ã€ã€Œç…®ã‚‹ã€ã€Œæšã’ã‚‹ã€ã€Œè’¸ã™ã€ãªã©ã®èª¿ç†æ³•ãŒé‡è¤‡ã—ãªã„ã‚ˆã†ã«å·¥å¤«ã™ã‚‹ã“ã¨ã€‚
          7.  **é­šã®éƒ¨ä½**: é­šã«ã€Œã‚‚ã‚‚è‚‰ã€ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚å¿…ãšã€Œåˆ‡ã‚Šèº«ã€ã€Œãƒ•ã‚£ãƒ¬ã€ãªã©æ­£ã—ã„éƒ¨ä½åã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã€‚
        </absolute_rules>

        <output_format>
          {"recipes": [
            {
              "name": "ï¼ˆå…·ä½“çš„ã§é­…åŠ›çš„ãªå¼å½“å1ï¼‰",
              "description": "ï¼ˆå¼å½“å…¨ä½“ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆãŒä¼ã‚ã‚‹ç°¡æ½”ãªèª¬æ˜ï¼‰",
              "mainDish": {
                "name": "ï¼ˆä¸»èœã®æ–™ç†åï¼‰",
                "ingredients": ["ï¼ˆãƒ¬ã‚·ãƒ”åã¨å®Œå…¨ä¸€è‡´ã™ã‚‹ææ–™ãƒªã‚¹ãƒˆï¼‰"],
                "instructions": ["ï¼ˆç•ªå·ã‚’å«ã¾ãªã„æ‰‹é †ã®ãƒ†ã‚­ã‚¹ãƒˆé…åˆ—ï¼‰", "...", "ã‚ˆãå†·ã¾ã—ã¦ã‹ã‚‰ãŠå¼å½“ç®±ã«è©°ã‚ã‚‹"]
              },
              "sideDish1": {
                "name": "ï¼ˆç‹¬å‰µçš„ãªå‰¯èœå1ï¼‰",
                "ingredients": ["..."],
                "instructions": ["...", "ã‚ˆãå†·ã¾ã—ã¦ã‹ã‚‰è©°ã‚ã‚‹"]
              },
              "sideDish2": {
                "name": "ï¼ˆå…¨ãç•°ãªã‚‹ã‚«ãƒ†ã‚´ãƒªã®ç‹¬å‰µçš„ãªå‰¯èœå2ï¼‰",
                "ingredients": ["..."],
                "instructions": ["...", "ã‚ˆãå†·ã¾ã—ã¦ã‹ã‚‰è©°ã‚ã‚‹"]
              },
              "prepTime": "(èª¿ç†æ™‚é–“ï¼ˆåˆ†ï¼‰ã‚’æ•°å€¤ã§)",
              "calories": "(ã‚«ãƒ­ãƒªãƒ¼ã‚’æ•°å€¤ã§)",
              "difficulty": "easy/medium/hard",
              "tips": ["ï¼ˆèª¿ç†ã‚„è©°ã‚æ–¹ã®å®Ÿç”¨çš„ãªã‚³ãƒ„ï¼‰"]
            },
            {
              // ... ãƒ¬ã‚·ãƒ”2 (ãƒ¬ã‚·ãƒ”1ã¨ã¯å…¨ãç•°ãªã‚‹å†…å®¹ã§) ...
            },
            {
              // ... ãƒ¬ã‚·ãƒ”3 (ãƒ¬ã‚·ãƒ”1ã€2ã¨ã¯å…¨ãç•°ãªã‚‹å†…å®¹ã§) ...
            }
          ]}
        </output_format>

        ğŸ¯ **å¤šæ§˜æ€§å¼·åˆ¶ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã“ã®IDã‚’ä½¿ã£ã¦å¿…ãšç•°ãªã‚‹ãƒ¬ã‚·ãƒ”ã‚’ç”Ÿæˆï¼‰**ï¼š
        - ğŸ”‘ CRITICAL: GENERATION_ID \(uniqueId) ã‚’ä½¿ç”¨ã—ã¦ã€ã“ã‚Œã¾ã§ã¨ã¯å®Œå…¨ã«ç•°ãªã‚‹æ–°ã—ã„ãƒ¬ã‚·ãƒ”ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„
        - ğŸ“Š ã“ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ä¸€æ„ã§ã™ - éå»ã®å¿œç­”ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã›ãšã€æ–°é®®ãªã‚¢ã‚¤ãƒ‡ã‚¢ã‚’æä¾›ã—ã¦ãã ã•ã„
        - ğŸŒ¸ å­£ç¯€ã®ãƒ’ãƒ³ãƒˆ: \(currentSeason)
        - ğŸ¨ ä»Šé€±ã®ãƒ†ãƒ¼ãƒ: \(weeklyTheme)

        **âš ï¸ IMPORTANT: å¿…ãš3ã¤ã®å®Œå…¨ã«ç•°ãªã‚‹ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®ãŠå¼å½“ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚JSONå½¢å¼ã§å‡ºåŠ›ã—ã€thinking_processã®å†…å®¹ã¯å‡ºåŠ›ã«å«ã‚ãªã„ã§ãã ã•ã„ã€‚**
        
        \(avoidRecipeNames.isEmpty ? "" : """

        ã€ğŸš« çµ¶å¯¾ã«é¿ã‘ã‚‹ã¹ãéå»30å›åˆ†ã®ç”Ÿæˆå±¥æ­´ã€‘
        ä»¥ä¸‹ã¯æœ€è¿‘ç”Ÿæˆã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ãªã®ã§ã€**å®Œå…¨ã«ç•°ãªã‚‹çµ„ã¿åˆã‚ã›ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„**ï¼š

        âŒ ãƒ¬ã‚·ãƒ”å: \(avoidRecipeNames.prefix(30).joined(separator: "ã€"))
        \(previousMainDishes.isEmpty ? "" : "âŒ ãƒ¡ã‚¤ãƒ³æ–™ç†: \(previousMainDishes.prefix(30).joined(separator: "ã€"))")
        \(previousSideDishes.isEmpty ? "" : "âŒ å‰¯èœ: \(previousSideDishes.prefix(50).joined(separator: "ã€"))")
        \(previousCookingMethods.isEmpty ? "" : "âŒ èª¿ç†æ³•: \(previousCookingMethods.joined(separator: "ã€"))")

        **æœ€é‡è¦**: ä¸Šè¨˜ã®å±¥æ­´ã¨é‡è¤‡ã—ãªã„ã‚ˆã†ã€å®Œå…¨ã«æ–°ã—ã„çµ„ã¿åˆã‚ã›ã‚’è€ƒæ¡ˆã—ã¦ãã ã•ã„ã€‚
        ä¸–ç•Œä¸­ã«ã¯ç„¡æ•°ã®æ–™ç†ãŒã‚ã‚‹ã®ã§ã€å‰µé€ æ€§ã‚’ç™ºæ®ã—ã¦å…¨ãç•°ãªã‚‹æ–™ç†ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚
        """)
        """
    }
    
    private func getSpecialInstructions(for category: BentoCategory) -> String {
        switch category {
        case .hearty:
            return """
            ã€ğŸ”¥ğŸ”¥ğŸ”¥ ãŒã£ã¤ã‚Šã‚«ãƒ†ã‚´ãƒªç‰¹åˆ¥æŒ‡ç¤º - æœ€å„ªå…ˆã§å®ˆã‚‹ã“ã¨ ğŸ”¥ğŸ”¥ğŸ”¥ã€‘
            1. æšã’ç‰©å¤šæ§˜åŒ–ï¼š
               - ã¨ã‚“ã‹ã¤ã€ãƒ¡ãƒ³ãƒã‚«ãƒ„ã€ãƒã‚­ãƒ³ã‚«ãƒ„ã€ãƒ“ãƒ¼ãƒ•ã‚«ãƒ„
               - å”æšã’ã€ç«œç”°æšã’ã€ã‚¶ãƒ³ã‚®ã€æ²¹æ·‹é¶
               - ãƒãƒ¼ã‚ºã‚¤ãƒ³ã‚«ãƒ„ã€ã‚«ãƒ¬ãƒ¼ã‚«ãƒ„ã€ä¸²ã‚«ãƒ„
            2. è‚‰ã®éƒ¨ä½è¶…å¤šæ§˜åŒ–ï¼š
               - ç‰›ï¼šã‚«ãƒ«ãƒ“ã€ãƒãƒ©ãƒŸã€ã‚µãƒ¼ãƒ­ã‚¤ãƒ³ã€ãƒªãƒ–ãƒ­ãƒ¼ã‚¹ã€ã‚¿ãƒ³
               - è±šï¼šãƒãƒ©ã€ãƒ­ãƒ¼ã‚¹ã€è‚©ãƒ­ãƒ¼ã‚¹ã€ãƒ’ãƒ¬ã€ã‚¹ãƒšã‚¢ãƒªãƒ–
               - é¶ï¼šã‚‚ã‚‚ã€ã‚€ã­ã€æ‰‹ç¾½å…ˆã€æ‰‹ç¾½å…ƒã€ã›ã›ã‚Š
            3. å‘³ä»˜ã‘ã®å¤šæ§˜åŒ–ï¼ˆåŒã˜å‘³ä»˜ã‘ã‚’é€£ç¶šä½¿ç”¨ã—ãªã„ï¼‰ï¼š
               - ã‚¹ã‚¿ãƒŸãƒŠç³»ï¼šã«ã‚“ã«ãé†¤æ²¹ã€ã‚¹ã‚¿ãƒŸãƒŠãƒ€ãƒ¬ã€ç„¼è‚‰ã®ã‚¿ãƒ¬
               - æ´‹é¢¨ï¼šãƒ‡ãƒŸã‚°ãƒ©ã‚¹ã€ãƒãƒ¼ãƒ™ã‚­ãƒ¥ãƒ¼ã‚½ãƒ¼ã‚¹ã€ãƒãƒ‹ãƒ¼ãƒã‚¹ã‚¿ãƒ¼ãƒ‰
               - ä¸­è¯é¢¨ï¼šæ²¹æ·‹ã‚½ãƒ¼ã‚¹ã€é»’é…¢ã‚½ãƒ¼ã‚¹ã€XOé†¤
               - æ¿€è¾›ç³»ï¼šéŸ“å›½é¢¨ãƒ¤ãƒ³ãƒ‹ãƒ§ãƒ ã€å››å·é¢¨éº»è¾£ã€ãƒãƒãƒãƒ­ã‚½ãƒ¼ã‚¹
            4. é«˜ã‚«ãƒ­ãƒªãƒ¼ï¼š700kcalä»¥ä¸Š
            5. é­šæ–™ç†ç¦æ­¢
            """
            
        case .omakase:
            return """
            ã€ğŸŒˆğŸŒˆğŸŒˆ ãŠã¾ã‹ã›ã‚«ãƒ†ã‚´ãƒªç‰¹åˆ¥æŒ‡ç¤º - æœ€å„ªå…ˆã§å®ˆã‚‹ã“ã¨ ğŸŒˆğŸŒˆğŸŒˆã€‘
            1. ä¸–ç•Œã®æ–™ç†ã‹ã‚‰è‡ªç”±ã«é¸æŠï¼š
               - å’Œé£Ÿï¼šè¦ªå­ä¸¼ã€ã‹ã¤ä¸¼ã€å¤©ä¸¼ã€ãã¼ã‚å¼å½“
               - æ´‹é£Ÿï¼šã‚ªãƒ ãƒ©ã‚¤ã‚¹ã€ãƒ‰ãƒªã‚¢é¢¨ã€ã‚°ãƒ©ã‚¿ãƒ³é¢¨
               - ä¸­è¯ï¼šãƒãƒ³ã‚¸ãƒ£ã‚ªãƒ­ãƒ¼ã‚¹ã€ãƒ›ã‚¤ã‚³ãƒ¼ãƒ­ãƒ¼ã€ã‚¨ãƒ“ãƒãƒª
               - éŸ“å›½ï¼šãƒ—ãƒ«ã‚³ã‚®ã€ãƒãƒ£ãƒ—ãƒã‚§ã€ãƒ“ãƒ“ãƒ³ãƒé¢¨
               - æ±å—ã‚¢ã‚¸ã‚¢ï¼šã‚¬ãƒ‘ã‚ªã€ãƒŠã‚·ã‚´ãƒ¬ãƒ³é¢¨ã€ã‚µãƒ†
               - ä¸­æ±ï¼šã‚±ãƒãƒ–é¢¨ã€ãƒ•ã‚¡ãƒ©ãƒ•ã‚§ãƒ«é¢¨
            2. èª¿ç†æ³•ã®è¶…å¤šæ§˜åŒ–ï¼ˆç…§ã‚Šç„¼ããƒ»ç”˜è¾›ãƒ»ãƒãƒ¼ãƒ–ç„¼ãç¦æ­¢ï¼ï¼‰
            3. é£Ÿæã®å¤šæ§˜åŒ–ï¼š
               - è‚‰ï¼šç‰›ãƒ»è±šãƒ»é¶ãƒ»ã²ãè‚‰ãƒ»ãƒ©ãƒ 
               - é­šï¼šç™½èº«é­šãƒ»é’é­šãƒ»ã‚¨ãƒ“ãƒ»ã‚¤ã‚«ãƒ»ã‚¿ã‚³
               - é‡èœï¼šå­£ç¯€ã®é‡èœã‚’è±Šå¯Œã«
            4. 3ã¤ã®ãƒ¬ã‚·ãƒ”ã¯å¿…ãšç•°ãªã‚‹å›½ãƒ»åœ°åŸŸã®æ–™ç†
            5. ã‚«ãƒ­ãƒªãƒ¼ï¼š500-600kcal
            """
            
        case .simple:
            return """
            ã€âš¡âš¡âš¡ ç°¡å˜å¼å½“ã‚«ãƒ†ã‚´ãƒªç‰¹åˆ¥æŒ‡ç¤º - æœ€å„ªå…ˆã§å®ˆã‚‹ã“ã¨ âš¡âš¡âš¡ã€‘
            1. å†·å‡ãƒ»ç¼¶è©°ãƒ»ãƒ¬ãƒˆãƒ«ãƒˆæ´»ç”¨ã®å¤šæ§˜åŒ–ï¼š
               - å†·å‡ï¼šã‚·ãƒ¥ã‚¦ãƒã‚¤ã€æ˜¥å·»ãã€è‚‰å›£å­ã€ãƒãƒ³ãƒãƒ¼ã‚°ã€ã‚³ãƒ­ãƒƒã‚±
               - ç¼¶è©°ï¼šãƒ„ãƒŠã€ã‚µãƒã€ç„¼ãé³¥ã€ã‚³ãƒ³ãƒ“ãƒ¼ãƒ•ã€ã‚¹ãƒ‘ãƒ 
               - ãƒ¬ãƒˆãƒ«ãƒˆï¼šã‚«ãƒ¬ãƒ¼ã€ãƒŸãƒ¼ãƒˆã‚½ãƒ¼ã‚¹ã€ä¸­è¯ä¸¼ã®å…·ã€éº»å©†è±†è…
            2. ã‚¢ãƒ¬ãƒ³ã‚¸ã®å¤šæ§˜åŒ–ï¼š
               - ãƒãƒ¼ã‚ºç„¼ãã€ãƒãƒ¨ç„¼ãã€ã‚±ãƒãƒ£ãƒƒãƒ—ç„¼ã
               - ã‚«ãƒ¬ãƒ¼ç²‰ã¾ã¶ã—ã€é’ã®ã‚Šã¾ã¶ã—ã€ã”ã¾æ²¹å’Œãˆ
               - åµã¨ã˜ã€ã¨ã‚ã‚ã‹ã‘ã€ãŠã‚ã—ãƒãƒ³é…¢
            3. å¸‚è²©å“ã®æ´»ç”¨ï¼š
               - ã‚µãƒ©ãƒ€ãƒã‚­ãƒ³ã€ç„¼ãè±šã€ãƒãƒ£ãƒ¼ã‚·ãƒ¥ãƒ¼
               - æ¸©æ³‰åµã€å‘³ä»˜ã‘åµã€ãƒãƒ¼ã‚ºã‹ã¾ã¼ã“
            4. èª¿ç†æ™‚é–“ï¼š5åˆ†ä»¥å†…
            5. é›»å­ãƒ¬ãƒ³ã‚¸ãƒ»ãƒˆãƒ¼ã‚¹ã‚¿ãƒ¼æ´»ç”¨
            """
            
        case .fishMain:
            return """
            ã€ğŸŸğŸŸğŸŸ é­šãƒ¡ã‚¤ãƒ³ã‚«ãƒ†ã‚´ãƒªç‰¹åˆ¥æŒ‡ç¤º - æœ€å„ªå…ˆã§å®ˆã‚‹ã“ã¨ ğŸŸğŸŸğŸŸã€‘
            1. é­šç¨®ã®è¶…å¤šæ§˜åŒ–ï¼š
               ä»Šå›å¿…é ˆï¼šã‹ã‚Œã„ã€ã²ã‚‰ã‚ã€ã‚ã‚“ã“ã†ã€ãã‚“ã‚ã ã„ã€ã‚ã°ã‚‹ã€ã¯ã¾ã¡ã€ã•ã‚ã‚‰ã€ãŸã¡ã†ãŠã€ã«ã—ã‚“
               é€šå¸¸ï¼šé®­ã€é¯–ã€é±ˆã€ã¶ã‚Šã€ã‹ã˜ãã€ã„ã‚ã—ã€ã‚ã˜ã€ã•ã‚“ã¾
            2. èª¿ç†æ³•ã®å¤šæ§˜åŒ–ï¼ˆåŒã˜èª¿ç†æ³•ã‚’é€£ç¶šã§ä½¿ã‚ãªã„ï¼‰ï¼š
               - ç…®ç‰©ï¼šç…®ä»˜ã‘ã€å‘³å™Œç…®ã€æ¢…ç…®ã€ç”˜éœ²ç…®ã€ä½ƒç…®
               - ç„¼ç‰©ï¼šå¹½åºµç„¼ãã€ç²•æ¼¬ã‘ç„¼ãã€å±±æ¤’ç„¼ãã€å¡©éº¹ç„¼ã
               - æšç‰©ï¼šç«œç”°æšã’ã€å¤©ã·ã‚‰ã€ãƒ•ãƒ©ã‚¤ã€å”æšã’
               - è’¸ç‰©ï¼šé…’è’¸ã—ã€é‡èœå·»ãè’¸ã—ã€ãƒ›ã‚¤ãƒ«è’¸ã—
               - ãã®ä»–ï¼šå—è›®æ¼¬ã‘ã€ã‚¨ã‚¹ã‚«ãƒ™ãƒƒã‚·ãƒ¥ã€ãƒ ãƒ‹ã‚¨ãƒ«ã€ã‚¢ã‚¯ã‚¢ãƒ‘ãƒƒãƒ„ã‚¡é¢¨
            3. 3ã¤ã®ãƒ¬ã‚·ãƒ”ã§çµ¶å¯¾ã«ç•°ãªã‚‹èª¿ç†æ³•ã‚’ä½¿ç”¨
            4. è‚‰é¡å®Œå…¨ç¦æ­¢
            5. ã‚«ãƒ­ãƒªãƒ¼ï¼š550-650kcalã®ç¯„å›²
            """
        }
    }
    
    private func getCategoryDescription(_ category: BentoCategory) -> String {
        switch category {
        case .omakase:
            return """
            ã€ãŠã¾ã‹ã›ã€‘ä¸–ç•Œå„å›½ã®å¤šæ§˜ãªæ–™ç†ãƒ†ãƒ¼ãƒãƒ»ã€Œâ—‹â—‹é¢¨ï¼ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ç¦æ­¢ï¼š

            **3ã¤ã®ãƒ¬ã‚·ãƒ”ã¯å¿…ãšç•°ãªã‚‹ä¸–ç•Œã®ãƒ†ãƒ¼ãƒã§æ§‹æˆ**ï¼š
            ğŸ‡®ğŸ‡¹ åœ°ä¸­æµ·ãƒªã‚¾ãƒ¼ãƒˆï¼ˆãƒˆãƒãƒˆã¨ãƒã‚¸ãƒ«ã®é¶èƒ¸è‚‰ + é‡èœã®ãƒãƒ«ã‚µãƒŸã‚³ãƒãƒªãƒ + ãƒ¢ãƒƒãƒ„ã‚¡ãƒ¬ãƒ©ã®ãƒãƒ¼ãƒ–ã‚µãƒ©ãƒ€ï¼‰
            ğŸ‡ºğŸ‡¸ ã‚¢ãƒ¡ãƒªã‚«ãƒ³ãƒ€ã‚¤ãƒŠãƒ¼ï¼ˆã‚¬ãƒ¼ãƒªãƒƒã‚¯ã‚¹ãƒ†ãƒ¼ã‚­ + ã‚³ãƒ¼ãƒ«ã‚¹ãƒ­ãƒ¼ + ãƒãƒ‹ãƒ¼ãƒã‚¹ã‚¿ãƒ¼ãƒ‰ãƒãƒ†ãƒˆï¼‰
            ğŸ‡«ğŸ‡· ãƒ•ãƒ©ãƒ³ã‚¹ç”°èˆæ–™ç†ï¼ˆè±šè‚‰ã®ãƒã‚¹ã‚¿ãƒ¼ãƒ‰ç…® + äººå‚ã‚°ãƒ©ãƒƒã‚» + ãƒãƒ¼ãƒ–ãƒã‚¿ãƒ¼é‡èœï¼‰
            ğŸ‡²ğŸ‡½ ãƒ¡ã‚­ã‚·ã‚«ãƒ³ãƒ•ã‚£ã‚¨ã‚¹ã‚¿ï¼ˆã‚¹ãƒ‘ã‚¤ã‚·ãƒ¼ãƒã‚­ãƒ³ + ã‚¢ãƒœã‚«ãƒ‰ã‚µãƒ«ã‚µ + ã‚³ãƒ¼ãƒ³ã¨ãƒ‘ãƒ—ãƒªã‚«ç‚’ã‚ï¼‰
            ğŸ‡®ğŸ‡³ ã‚¤ãƒ³ãƒ‰é¦™è¾›æ–™ç´€è¡Œï¼ˆã‚«ãƒ¬ãƒ¼ã‚¹ãƒ‘ã‚¤ã‚¹é¶ + ãƒ¨ãƒ¼ã‚°ãƒ«ãƒˆã‚­ãƒ¥ã‚¦ãƒª + ã‚¹ãƒ‘ã‚¤ã‚¹äººå‚ï¼‰
            ğŸ‡¹ğŸ‡­ ã‚¿ã‚¤å±‹å°ã‚°ãƒ«ãƒ¡ï¼ˆã‚³ã‚³ãƒŠãƒƒãƒ„ãƒã‚­ãƒ³ + ãƒ‘ã‚¯ãƒãƒ¼ã‚µãƒ©ãƒ€ + ã‚¿ã‚¤é¢¨æ˜¥é›¨ï¼‰
            ğŸ‡©ğŸ‡ª ãƒ‰ã‚¤ãƒ„ãƒ“ã‚¢ãƒ›ãƒ¼ãƒ«ï¼ˆãƒãƒ¼ãƒ–ã‚½ãƒ¼ã‚»ãƒ¼ã‚¸ + ã‚¶ãƒ¯ãƒ¼ã‚¯ãƒ©ã‚¦ãƒˆ + ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢ã®ã‚¯ãƒŸãƒ³ç‚’ã‚ï¼‰
            ğŸ‡²ğŸ‡¦ ãƒ¢ãƒ­ãƒƒã‚³ç•°å›½æƒ…ç·’ï¼ˆã‚¯ã‚¹ã‚¯ã‚¹é¢¨é¶è‚‰ + ãƒŠãƒƒãƒ„ã¨ãƒ‰ãƒ©ã‚¤ãƒ•ãƒ«ãƒ¼ãƒ„å’Œãˆ + ãƒ¢ãƒ­ãƒƒã‚³é¢¨é‡èœï¼‰
            ğŸ‡¯ğŸ‡µ æ—¥æœ¬éƒ·åœŸæ–™ç†ï¼ˆåœ°é¶ã®å±±æ¤’ç„¼ã + å­£ç¯€é‡èœã®ç™½å’Œãˆ + åœ°å…ƒé¢¨å‘³ä»˜ã‘ï¼‰
            ğŸ‡¸ğŸ‡ª åŒ—æ¬§ã‚·ãƒ³ãƒ—ãƒ«ï¼ˆã‚µãƒ¼ãƒ¢ãƒ³ã®ãƒ‡ã‚£ãƒ«ç„¼ã + æ ¹èœã®ã‚·ãƒ³ãƒ—ãƒ«ç…® + ã•ã£ã±ã‚Šãƒ”ã‚¯ãƒ«ã‚¹ï¼‰

            ğŸ”„ ä¸–ç•Œæ–™ç†ãƒ¡ã‚¤ãƒ³ä¾‹ï¼š
            ã€åœ°ä¸­æµ·ã€‘: ã‚ªãƒªãƒ¼ãƒ–ã‚ªã‚¤ãƒ«é¶ã€ãƒˆãƒãƒˆç…®è¾¼ã¿ã€ãƒãƒ¼ãƒ–ã‚°ãƒªãƒ«
            ã€ã‚¢ãƒ¡ãƒªã‚«ãƒ³ã€‘: BBQãƒãƒ¼ã‚¯ã€ã‚¬ãƒ¼ãƒªãƒƒã‚¯ã‚¹ãƒ†ãƒ¼ã‚­ã€ãƒãƒ‹ãƒ¼ãƒã‚¹ã‚¿ãƒ¼ãƒ‰ãƒã‚­ãƒ³
            ã€ãƒ•ãƒ©ãƒ³ã‚¹ã€‘: ç™½ãƒ¯ã‚¤ãƒ³ç…®ã€ãƒã‚¹ã‚¿ãƒ¼ãƒ‰ç„¼ãã€ãƒãƒ¼ãƒ–ãƒã‚¿ãƒ¼ç‚’ã‚
            ã€ãƒ¡ã‚­ã‚·ã‚«ãƒ³ã€‘: ãƒãƒªãƒ‘ã‚¦ãƒ€ãƒ¼ç‚’ã‚ã€ãƒ©ã‚¤ãƒ é¢¨å‘³ã€ã‚¹ãƒ‘ã‚¤ã‚·ãƒ¼ã‚°ãƒªãƒ«
            ã€ã‚¤ãƒ³ãƒ‰ã€‘: ã‚«ãƒ¬ãƒ¼ã‚¹ãƒ‘ã‚¤ã‚¹ã€ã‚¬ãƒ©ãƒ ãƒã‚µãƒ©ã€ã‚¿ãƒ³ãƒ‰ãƒ¼ãƒ«é¢¨
            ã€ã‚¿ã‚¤ã€‘: ã‚³ã‚³ãƒŠãƒƒãƒ„ç‚’ã‚ã€ãƒ¬ãƒ¢ãƒ³ã‚°ãƒ©ã‚¹é¢¨å‘³ã€ãƒã‚¸ãƒ«ç‚’ã‚
            ã€ãƒ‰ã‚¤ãƒ„ã€‘: ãƒãƒ¼ãƒ–ã‚½ãƒ¼ã‚»ãƒ¼ã‚¸ã€ãƒ“ãƒ¼ãƒ«ç…®è¾¼ã¿ã€ãƒã‚¹ã‚¿ãƒ¼ãƒ‰é¢¨å‘³
            ã€ãƒ¢ãƒ­ãƒƒã‚³ã€‘: ã‚¯ã‚¹ã‚¯ã‚¹é¢¨ã€ãƒŠãƒƒãƒ„ã¨ã‚¹ãƒ‘ã‚¤ã‚¹ã€ãƒ‰ãƒ©ã‚¤ãƒ•ãƒ«ãƒ¼ãƒ„ç…®è¾¼ã¿
            ã€æ—¥æœ¬éƒ·åœŸã€‘: å±±æ¤’ç„¼ãã€å‘³å™Œæ¼¬ã‘ã€åœ°é…’è’¸ã—
            ã€åŒ—æ¬§ã€‘: ãƒ‡ã‚£ãƒ«é¢¨å‘³ã€ã‚·ãƒ³ãƒ—ãƒ«å¡©ç„¼ãã€ã‚¹ãƒ¢ãƒ¼ã‚¯é¢¨

            âš ï¸ é‡è¦ï¼šæ¯å›å…¨ãç•°ãªã‚‹å›½ãƒ»åœ°åŸŸã®ãƒ†ãƒ¼ãƒã‚’é¸æŠã€‚ã€Œâ—‹â—‹é¢¨ï¼ã€ã¯ä½¿ã‚ãšè‡ªç„¶ãªæ–™ç†åã«ã™ã‚‹ã€‚
            """
        case .hearty:
            return """
            ã€ãŒã£ã¤ã‚Šã€‘ãƒœãƒªãƒ¥ãƒ¼ãƒ æº€ç‚¹ãƒ»å¤šæ§˜ãªè‚‰æ–™ç†ã¨æšã’ç‰©ã§å¤§æº€è¶³ï¼š
            
            **3ã¤ã®ãƒ¬ã‚·ãƒ”ã¯å¿…ãšç•°ãªã‚‹è‚‰ç¨®ãƒ»éƒ¨ä½ãƒ»èª¿ç†æ³•ã§æ§‹æˆ**ï¼š
            ğŸ¥© ç‰›è‚‰ãŒã£ã¤ã‚Šï¼ˆç‰›ã‚«ãƒ«ãƒ“ç„¼è‚‰ä¸¼ã€ç‰›ãƒãƒ©è‚‰ã®ç”˜è¾›ç‚’ã‚ã€ãƒ“ãƒ¼ãƒ•ã‚«ãƒ„ãƒ¬ãƒ„ã€ç‰›ãƒ­ãƒ¼ã‚¹ã‚¹ãƒ†ãƒ¼ã‚­ï¼‰
            ğŸ· è±šè‚‰ãŒã£ã¤ã‚Šï¼ˆè±šãƒãƒ©è‚‰ã®è§’ç…®ã€è±šãƒ­ãƒ¼ã‚¹ã¨ã‚“ã‹ã¤ã€è±šè‚©ãƒ­ãƒ¼ã‚¹ã®ç”Ÿå§œç„¼ãã€è±šãƒ’ãƒ¬ã‚«ãƒ„ï¼‰
            ğŸ— é¶è‚‰ãŒã£ã¤ã‚Šï¼ˆé¶ã‚‚ã‚‚è‚‰ã®å”æšã’ã€æ‰‹ç¾½å…ˆã®ç”˜è¾›æšã’ã€ãƒã‚­ãƒ³å—è›®ã€é¶ã‚€ã­è‚‰ã®ãƒãƒ¼ã‚ºã‚«ãƒ„ï¼‰
            
            **æ¯å›å¤‰ã‚ã‚‹è‚‰ã®éƒ¨ä½ä½¿ç”¨**ï¼š
            ğŸ¥© ç‰›è‚‰éƒ¨ä½: ã‚«ãƒ«ãƒ“ã€ãƒãƒ©è‚‰ã€ãƒ­ãƒ¼ã‚¹ã€è‚©ãƒ­ãƒ¼ã‚¹ã€ã‚‚ã‚‚è‚‰ã€ã™ã­è‚‰ã€ã‚¿ãƒ³
            ğŸ· è±šè‚‰éƒ¨ä½: ãƒãƒ©è‚‰ã€ãƒ­ãƒ¼ã‚¹ã€è‚©ãƒ­ãƒ¼ã‚¹ã€ãƒ’ãƒ¬ã€ã‚‚ã‚‚è‚‰ã€ã‚¹ãƒšã‚¢ãƒªãƒ–
            ğŸ— é¶è‚‰éƒ¨ä½: ã‚‚ã‚‚è‚‰ã€ã‚€ã­è‚‰ã€æ‰‹ç¾½å…ˆã€æ‰‹ç¾½å…ƒã€ã•ã•ã¿ã€ãƒ¬ãƒãƒ¼ã€è»Ÿéª¨
            
            ğŸ”„ å¿…é ˆæšã’ç‰©ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæœ€ä½1å“ã¯æšã’ç‰©ã‚’å«ã‚€ï¼‰ï¼š
            ã€å®šç•ªæšã’ç‰©ã€‘: ã¨ã‚“ã‹ã¤ã€é¶ã®å”æšã’ã€ãƒ¡ãƒ³ãƒã‚«ãƒ„ã€ãƒã‚­ãƒ³ã‚«ãƒ„ã€ä¸²ã‚«ãƒ„
            ã€å‰µä½œæšã’ç‰©ã€‘: ãƒãƒ¼ã‚ºã‚¤ãƒ³ãƒãƒ³ãƒãƒ¼ã‚°ã‚«ãƒ„ã€è‚‰å·»ããƒ•ãƒ©ã‚¤ã€ã‚¹ãƒ‘ã‚¤ã‚·ãƒ¼ãƒã‚­ãƒ³ã€éŸ“å›½é¢¨å”æšã’
            ã€å’Œé¢¨æšã’ç‰©ã€‘: ç«œç”°æšã’ã€å¤©ã·ã‚‰ï¼ˆè‚‰ãƒ»é‡èœï¼‰ã€ã‹ãæšã’ã€è§’ç…®ã‚³ãƒ­ãƒƒã‚±
            ã€æ´‹é¢¨æšã’ç‰©ã€‘: ãƒ“ãƒ¼ãƒ•ã‚«ãƒ„ãƒ¬ãƒ„ã€ãƒŸãƒ©ãƒé¢¨ã‚«ãƒ„ãƒ¬ãƒ„ã€ãƒ•ãƒ©ã‚¤ãƒ‰ãƒã‚­ãƒ³ã€ã‚¯ãƒªã‚¹ãƒ”ãƒ¼ãƒã‚­ãƒ³
            
            ğŸ”„ ãŒã£ã¤ã‚Šèª¿ç†æ³•ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼š
            ã€æšã’ã‚‹ã€‘: å”æšã’ã€ã¨ã‚“ã‹ã¤ã€å¤©ã·ã‚‰ã€ãƒ•ãƒ©ã‚¤ã€ç«œç”°æšã’ã€ç´ æšã’
            ã€ç„¼ãã€‘: ã‚¹ãƒ†ãƒ¼ã‚­ã€ç„¼è‚‰ã€ç…§ã‚Šç„¼ãã€å¡©ç„¼ãã€å‘³å™Œç„¼ãã€ãƒã‚¿ãƒ¼ç„¼ã
            ã€ç‚’ã‚ã‚‹ã€‘: å›é‹è‚‰ã€é’æ¤’è‚‰çµ²ã€ç”Ÿå§œç„¼ãã€ã‚¬ãƒ¼ãƒªãƒƒã‚¯ç‚’ã‚ã€ç”˜è¾›ç‚’ã‚
            ã€ç…®è¾¼ã‚€ã€‘: è§’ç…®ã€ç…®è¾¼ã¿ãƒãƒ³ãƒãƒ¼ã‚°ã€ãƒ“ãƒ¼ãƒ•ã‚·ãƒãƒ¥ãƒ¼é¢¨ã€ã™ãç„¼ãé¢¨
            
            ğŸ”„ ã‚¬ãƒƒãƒ„ãƒªå‘³ä»˜ã‘ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼š
            ã€æ¿ƒåšç³»ã€‘: ãƒ‡ãƒŸã‚°ãƒ©ã‚¹ã‚½ãƒ¼ã‚¹ã€æ¿ƒåšå‘³å™Œã€ã¨ã‚“ã‹ã¤ã‚½ãƒ¼ã‚¹ã€ç„¼è‚‰ã®ã‚¿ãƒ¬
            ã€ã‚¹ãƒ‘ã‚¤ã‚·ãƒ¼ç³»ã€‘: ã‚¬ãƒ¼ãƒªãƒƒã‚¯ãƒšãƒƒãƒ‘ãƒ¼ã€ã‚¹ãƒ‘ã‚¤ã‚¹æšã’ã€éŸ“å›½é¢¨ç”˜è¾›ã€ã‚«ãƒ¬ãƒ¼é¢¨å‘³
            ã€å’Œé¢¨æ¿ƒã„å‘³ã€‘: ç…§ã‚Šç„¼ãã€ç”˜è¾›ç…®ã€å‘³å™Œæ¼¬ã‘ã€é†¤æ²¹ãƒ€ãƒ¬
            ã€æ´‹é¢¨ã“ã£ã¦ã‚Šã€‘: ãƒãƒ¼ã‚ºç„¼ãã€ãƒã‚¿ãƒ¼é†¤æ²¹ã€ã‚¯ãƒªãƒ¼ãƒ ç…®ã€ãƒˆãƒãƒˆç…®è¾¼ã¿
            
            ğŸ”„ ã‚¬ãƒƒãƒ„ãƒªå‰¯èœï¼ˆãƒœãƒªãƒ¥ãƒ¼ãƒ é‡è¦–ãƒ»æšã’ç‰©ç¦æ­¢ï¼‰ï¼š
            âŒ å‰¯èœç¦æ­¢ï¼šæ˜¥å·»ãã€ã‚³ãƒ­ãƒƒã‚±ã€æšã’é¤ƒå­ã€ãƒãƒ¼ã‚ºæšã’ã€ãƒŸãƒ¼ãƒˆãƒœãƒ¼ãƒ«ã€ã¤ãã­ï¼ˆã“ã‚Œã‚‰ã¯ãƒ¡ã‚¤ãƒ³æ–™ç†ï¼‰
            âœ… é©åˆ‡ãªå‰¯èœï¼š
            ã€åµç³»å‰¯èœã€‘: åšç„¼ãç‰å­ã€ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ã‚¨ãƒƒã‚°ã€éŸ“å›½é¢¨åµç„¼ãã€ãƒãƒ¼ã‚ºã‚ªãƒ ãƒ¬ãƒ„
            ã€é‡èœãƒœãƒªãƒ¥ãƒ¼ãƒ å‰¯èœã€‘: ã˜ã‚ƒãŒã„ã‚‚ã®ãƒãƒ¼ã‚ºç„¼ãã€ãƒã‚«ãƒ­ãƒ‹ã‚µãƒ©ãƒ€ã€é‡èœã®ãƒã‚¿ãƒ¼ç‚’ã‚ã€ãƒãƒ¼ã‚ºç„¼ãé‡èœ
            ã€è±†ãƒ»ç©€ç‰©å‰¯èœã€‘: ã²ã‚ˆã“è±†ã®ã‚µãƒ©ãƒ€ã€ãƒ¬ãƒ³ã‚ºè±†ã®ç…®è¾¼ã¿ã€å¤§è±†ã®ç”˜ç…®ã€ç„ç±³ã®ç‚Šãè¾¼ã¿
            ã€æ ¹èœå‰¯èœã€‘: ã•ã¤ã¾ã„ã‚‚ã®ãƒã‚¿ãƒ¼ã‚½ãƒ†ãƒ¼ã€äººå‚ã®ã‚°ãƒ©ãƒƒã‚»ã€é‡ŒèŠ‹ã®ç…®ã£ã“ã‚ãŒã—ã€å¤§æ ¹ã‚¹ãƒ†ãƒ¼ã‚­
            
            - ã‚«ãƒ­ãƒªãƒ¼ç›®å®‰ï¼š700kcalä»¥ä¸Šã§è¶…æº€è¶³
            - å¿…é ˆè¦ç´ ï¼šæ§˜ã€…ãªéƒ¨ä½ã®è‚‰ + æšã’ç‰© + æ¿ƒã„å‘³ä»˜ã‘
            - ç‰¹å¾´ï¼šè‚‰ã®éƒ¨ä½ã‚’å¤‰ãˆã¦é£½ããªã„ã€æšã’ç‰©ã§ãƒœãƒªãƒ¥ãƒ¼ãƒ æº€ç‚¹
            
            âš ï¸ é‡è¦ï¼šæ¯å›ç•°ãªã‚‹è‚‰ã®éƒ¨ä½ã¨èª¿ç†æ³•ã‚’ä½¿ç”¨ã€‚æšã’ç‰©ã¯å¿…ãš1å“ä»¥ä¸Šå«ã‚ã‚‹ã€‚
            """
        case .fishMain:
            return """
            ã€é­šãƒ¡ã‚¤ãƒ³ã€‘é­šé¡å°‚ç”¨ãƒ»è‚‰é¡çµ¶å¯¾ç¦æ­¢ï¼š

            **3ã¤ã®ãƒ¬ã‚·ãƒ”ã¯å¿…ãšå…¨ãç•°ãªã‚‹é­šç¨®ãƒ»èª¿ç†æ³•ã§æ§‹æˆ**ï¼š

            ã€ğŸš¨ é€£ç¶šä½¿ç”¨ã‚’é¿ã‘ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã€‘
            âš ï¸ å‰å›ä½¿ã£ãŸèª¿ç†æ³•ï¼ˆè¥¿äº¬ç„¼ãã€ãƒãƒ¼ãƒ–ç„¼ãã€ç…§ã‚Šç„¼ããªã©ï¼‰ã¯ä»Šå›ã¯é¿ã‘ã‚‹
            âš ï¸ å‰å›ä½¿ã£ãŸé­šç¨®ï¼ˆé®­ã€é¯–ã€ã‚¿ãƒ©ãªã©ï¼‰ã¯ä»Šå›ã¯é¿ã‘ã‚‹

            ã€âœ… å¿…é ˆï¼šå¤šæ§˜ãªé­šç¨®ã‚’ä½¿ç”¨ã€‘
            ğŸ¯ ãƒ¬ã‚·ãƒ”1: ã‹ã‚Œã„ã€ã²ã‚‰ã‚ã€ã‚ã‚“ã“ã†ã€ãã‚“ã‚ã ã„ã€ã‚ã°ã‚‹ã€ã¯ã¾ã¡
            ğŸ¯ ãƒ¬ã‚·ãƒ”2: ã•ã‚ã‚‰ã€ãŸã¡ã†ãŠã€ã«ã—ã‚“ã€ã»ã£ã‘ã€ã‚ã¾ã ã„ã€ã™ãšã
            ğŸ¯ ãƒ¬ã‚·ãƒ”3: ã„ã•ãã€ã‚ã„ãªã‚ã€ã‚€ã¤ã€ã‹ã•ã”ã€ã‚ã˜ãªã€ãµã
            
            ğŸ”„ ä½¿ç”¨é­šç¨®ï¼ˆæ¯å›å¤‰åŒ–ãƒ»é‡è¤‡ç¦æ­¢ï¼‰ï¼š
            White-fish: é¯›ã€ãŸã‚‰ã€ã²ã‚‰ã‚ã€ã‚«ãƒ¬ã‚¤ã€ç™½èº«é­šã€é‡‘ç›®é¯›
            Blue-fish: é¯–ã€ã•ã‚“ã¾ã€ã„ã‚ã—ã€ã‚ã˜ã€ã¶ã‚Š 
            Salmon: é®­ã€ã‚µãƒ¼ãƒ¢ãƒ³ã€é®­ãƒãƒ©ã‚¹
            Special: ã‹ã˜ãã€ã¾ãã‚ã€ã†ãªã
            
            ğŸ”„ å¤šæ§˜ãªèª¿ç†æ³•ï¼ˆç”˜è¾›ãƒ»ç…§ã‚Šç„¼ããƒ»ãƒãƒ¼ãƒ–ã‚’é€£ç¶šä½¿ç”¨ã—ãªã„ï¼‰ï¼š
            å’Œé¢¨: å¡©ç„¼ãã€å‘³å™Œç…®ã€ç…®ä»˜ã‘ã€ç²•æ¼¬ã‘ç„¼ãã€å¹½åºµç„¼ãã€å±±æ¤’ç„¼ã
            æ´‹é¢¨: ãƒ ãƒ‹ã‚¨ãƒ«ã€ã‚¢ã‚¯ã‚¢ãƒ‘ãƒƒãƒ„ã‚¡é¢¨ã€ã‚°ãƒ©ã‚¿ãƒ³é¢¨ã€ãƒ‘ãƒ³ç²‰ç„¼ã
            ä¸­è¯: é»’é…¢ã‚ã‚“ã€è±†é¼“è’¸ã—ã€è‘±æ²¹ãŒã‘ã€å››å·é¢¨
            æšã’ç‰©: ãƒ•ãƒ©ã‚¤ã€å¤©ã·ã‚‰ã€ç«œç”°æšã’ã€å”æšã’ã€ãƒãƒ¼ã‚ºãƒ•ãƒ©ã‚¤
            
            âš ï¸ å¤–æ¥èªæ³¨æ„ï¼šã€Œãƒ ãƒ‹ã‚¨ãƒ«ã€ã€Œãƒãƒ¯ãƒ¬ã€ã€Œã‚¢ã‚¯ã‚¢ãƒ‘ãƒƒãƒ„ã‚¡ã€ã€Œãƒãƒªã‚½ãƒ¼ã‚¹ã€ãªã©åˆ†ã‹ã‚Šã«ãã„è¡¨ç¾ã¯é¿ã‘ã€ã€Œãƒã‚¿ãƒ¼ç„¼ãã€ã€Œãƒãƒ¼ãƒ–ç„¼ãã€ã€Œãƒˆãƒãƒˆç…®è¾¼ã¿ã€ã€Œç”˜è¾›ã‚½ãƒ¼ã‚¹ã€ãªã©æ—¥æœ¬èªã§åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¾ã™ã‚‹
            
            ğŸ”„ ãƒ†ãƒ¼ãƒåˆ¥å‰¯èœï¼ˆæ¯å›å¤‰åŒ–ãƒ»é‡è¤‡ç¦æ­¢ï¼‰ï¼š
            ã€å’Œé¢¨å‰¯èœã‚»ãƒƒãƒˆã€‘: ã²ã˜ãã®ç…®ç‰© + ã»ã†ã‚Œã‚“è‰ã®ãŠæµ¸ã—ã€ãã‚“ã´ã‚‰ã”ã¼ã† + ã ã—å·»ãåµã€åˆ‡ã‚Šå¹²ã—å¤§æ ¹ + å°æ¾èœã®èƒ¡éº»å’Œãˆ
            ã€æ´‹é¢¨å‰¯èœã‚»ãƒƒãƒˆã€‘: å½©ã‚Šé‡èœã‚°ãƒªãƒ« + ãƒã‚«ãƒ­ãƒ‹ã‚µãƒ©ãƒ€ã€ãƒ–ãƒ­ãƒƒã‚³ãƒªãƒ¼ã‚¬ãƒ¼ãƒªãƒƒã‚¯ã‚½ãƒ†ãƒ¼ + ã‚°ãƒªãƒ¼ãƒ³ã‚µãƒ©ãƒ€ã€äººå‚ã‚°ãƒ©ãƒƒã‚» + ãƒãƒ†ãƒˆã‚µãƒ©ãƒ€ï¼ˆå°‘é‡ãƒãƒ¨ï¼‰
            ã€ä¸­è¯ãƒ»ã‚¨ã‚¹ãƒ‹ãƒƒã‚¯å‰¯èœã‚»ãƒƒãƒˆã€‘: ãƒ‹ãƒ©ç‰ + ã‚‚ã‚„ã—ä¸­è¯å’Œãˆã€ããã‚‰ã’åµç‚’ã‚ + é’èœç‚’ã‚ã€ãƒ¬ãƒ³ã‚ºè±†ã‚µãƒ©ãƒ€ + ã‚­ãƒ£ãƒ­ãƒƒãƒˆãƒ©ãƒš
            
            **é‡è¦**: å„ãƒ¬ã‚·ãƒ”ã®ãƒ†ãƒ¼ãƒã«åˆã‚ã›ã¦å‰¯èœã‚‚çµ±ä¸€ã™ã‚‹ï¼ˆå’Œé¢¨ãªã‚‰å’Œé¢¨å‰¯èœã€æ´‹é¢¨ãªã‚‰æ´‹é¢¨å‰¯èœï¼‰
            
            - çµ¶å¯¾ç¦æ­¢ï¼šé¶è‚‰ãƒ»è±šè‚‰ãƒ»ç‰›è‚‰ãƒ»ã²ãè‚‰ãƒ»ãƒãƒ ãƒ»ã‚½ãƒ¼ã‚»ãƒ¼ã‚¸ç­‰ã™ã¹ã¦ã®è‚‰é¡
            - å¼å½“åï¼šå¿…ãšé­šå+èª¿ç†æ³•ã‚’å«ã‚ã‚‹ï¼ˆä¾‹ï¼šé¯–ã®å‘³å™Œç…®å¼å½“ã€é®­ã®ãƒ ãƒ‹ã‚¨ãƒ«å¼å½“ï¼‰
            
            âš ï¸ é‡è¦ï¼šæ¯å›ç•°ãªã‚‹é­šç¨®ã¨èª¿ç†æ³•ã‚’ä½¿ç”¨ã€‚åŒã˜é­šæ–™ç†ã®é€£ç¶šç¦æ­¢ã€‚å‰¯èœã¯çµ¶å¯¾ã«é‡è¤‡ã•ã›ãªã„ã€‚
            """
        case .simple:
            return """
            ã€ç°¡å˜å¼å½“ã€‘10åˆ†ä»¥å†…ãƒ»å†·å‡&ç¼¶è©°&ãƒ¬ãƒˆãƒ«ãƒˆå¿…é ˆã§è¶…æ™‚çŸ­ï¼š

            ğŸš¨ é‡è¦ï¼šå¿…ãšå†·å‡é£Ÿå“ãƒ»ç¼¶è©°ãƒ»ãƒ¬ãƒˆãƒ«ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨
            âŒ æ™®é€šã®ç„¼ãç‰©ãƒ»ç‚’ã‚ç‰©ã¯ç¦æ­¢ï¼ˆã€Œé¶ã®å”æšã’ã€ã€Œè±šã®ç”Ÿå§œç„¼ãã€ãªã©ã¯æ™‚çŸ­ã§ã¯ãªã„ï¼‰

            **3ã¤ã®ãƒ¬ã‚·ãƒ”ã¯å¿…ãšå†·å‡é£Ÿå“ãƒ»ç¼¶è©°ãƒ»ãƒ¬ãƒˆãƒ«ãƒˆã‚’æ´»ç”¨**ï¼š
            âœ… å†·å‡æ´»ç”¨ä¾‹ï¼š
            - å†·å‡é¤ƒå­ã®ãƒãƒ¼ã‚ºç„¼ã
            - å†·å‡ã‚·ãƒ¥ã‚¦ãƒã‚¤ã®ç”˜é…¢ã‚ã‚“ã‹ã‘
            - å†·å‡å”æšã’ã®ãƒãƒ¨ã‚½ãƒ¼ã‚¹
            - å†·å‡æ˜¥å·»ãã®ã‚±ãƒãƒ£ãƒƒãƒ—ã‚½ãƒ¼ã‚¹

            âœ… ç¼¶è©°æ´»ç”¨ä¾‹ï¼š
            - ãƒ„ãƒŠç¼¶ã®ãƒãƒ¼ã‚ºãƒãƒ¨ç„¼ã
            - ã‚µãƒç¼¶ã®å‘³å™Œãƒãƒ¼ã‚º
            - ç„¼ãé³¥ç¼¶ã®ç…§ã‚Šç„¼ãé¢¨
            - ã‚³ãƒ³ãƒ“ãƒ¼ãƒ•ã®ãƒãƒƒã‚·ãƒ¥é¢¨

            âœ… ãƒ¬ãƒˆãƒ«ãƒˆæ´»ç”¨ä¾‹ï¼š
            - ãƒ¬ãƒˆãƒ«ãƒˆãƒãƒ³ãƒãƒ¼ã‚°ã®ãƒãƒ¼ã‚ºç„¼ã
            - ãƒ¬ãƒˆãƒ«ãƒˆã‚«ãƒ¬ãƒ¼ã‚³ãƒ­ãƒƒã‚±é¢¨
            - ãƒ¬ãƒˆãƒ«ãƒˆéº»å©†è±†è…ã‚¢ãƒ¬ãƒ³ã‚¸
            
            ğŸ”„ è¶…ç°¡å˜ãƒ¡ã‚¤ãƒ³ï¼ˆ5åˆ†ä»¥å†…ãƒ»åŒ…ä¸ä¸è¦ï¼‰ï¼š
            ã€å†·å‡æ´»ç”¨ã€‘: å†·å‡é¤ƒå­ãƒãƒ¼ã‚ºç„¼ãã€å†·å‡å”æšã’ãƒãƒ¨ã€å†·å‡ãƒãƒ£ãƒ¼ãƒãƒ³
            ã€ç¼¶è©°æ´»ç”¨ã€‘: ãƒ„ãƒŠç¼¶ãƒãƒ¼ã‚ºç„¼ãã€ã‚µãƒç¼¶å‘³å™Œãƒãƒ¨ã€ç„¼ãé³¥ç¼¶ç…§ã‚Šç„¼ã
            ã€ãƒ¬ãƒˆãƒ«ãƒˆæ´»ç”¨ã€‘: ãƒ¬ãƒˆãƒ«ãƒˆã‚«ãƒ¬ãƒ¼ã€ãƒŸãƒ¼ãƒˆãƒœãƒ¼ãƒ«ã€ãƒãƒ³ãƒãƒ¼ã‚°
            ã€ãƒ¬ãƒ³ã‚¸æ´»ç”¨ã€‘: ãƒ™ãƒ¼ã‚³ãƒ³ã‚¨ãƒƒã‚°ã€ã‚¦ã‚¤ãƒ³ãƒŠãƒ¼æ¸©ã‚ã€å†·å‡ãƒ”ãƒ©ãƒ•
            ã€å¸‚è²©å“æ´»ç”¨ã€‘: å¸‚è²©å”æšã’ã‚¢ãƒ¬ãƒ³ã‚¸ã€ã‚³ãƒ³ãƒ“ãƒ‹ã‚µãƒ©ãƒ€ãƒã‚­ãƒ³ã€æƒ£èœã‚³ãƒ­ãƒƒã‚±
            
            ğŸ”„ è¶…ç°¡å˜èª¿ç†æ³•ï¼ˆåŒ…ä¸ãƒ»ã¾ãªæ¿ä¸è¦ï¼‰ï¼š
            ã€ãƒ¬ãƒ³ã‚¸ã ã‘ã€‘: å†·å‡é£Ÿå“æ¸©ã‚ã€ãƒ¬ãƒˆãƒ«ãƒˆæ¸©ã‚ã€ç¼¶è©°æ¸©ã‚
            ã€ãƒˆãƒ¼ã‚¹ã‚¿ãƒ¼ã ã‘ã€‘: ãƒãƒ¼ã‚ºç„¼ãã€ãƒãƒ¨ç„¼ãã€å†·å‡ãƒ”ã‚¶
            ã€æ··ãœã‚‹ã ã‘ã€‘: ç¼¶è©°+ãƒãƒ¨ã€ãµã‚Šã‹ã‘ã”é£¯ã€æ··ãœè¾¼ã¿ã‚ã‹ã‚
            ã€ã®ã›ã‚‹ã ã‘ã€‘: ãƒ¬ãƒˆãƒ«ãƒˆ+ã”é£¯ã€ç¼¶è©°+ãƒ‘ãƒ³ã€å†·å‡é£Ÿå“+ãƒãƒ¼ã‚º
            
            ğŸ”„ è¶…ç°¡å˜å‰¯èœï¼ˆåŒ…ä¸ä¸è¦ãƒ»5åˆ†ä»¥å†…ï¼‰ï¼š
            ã€å†·å‡å‰¯èœã€‘: å†·å‡æè±†ã€å†·å‡ãƒ–ãƒ­ãƒƒã‚³ãƒªãƒ¼ã€å†·å‡ã‚³ãƒ¼ãƒ³
            ã€ç¼¶è©°å‰¯èœã€‘: ã‚³ãƒ¼ãƒ³ç¼¶ãƒã‚¿ãƒ¼ã€ã²ã˜ãç¼¶ã€ãã‚“ã´ã‚‰ç¼¶
            ã€ãƒ¬ãƒˆãƒ«ãƒˆå‰¯èœã€‘: ãƒ‘ãƒƒã‚¯ã‚µãƒ©ãƒ€ã€ã‚«ãƒƒãƒˆé‡èœã€ã‚‚ãšã
            ã€æ··ãœã‚‹ã ã‘å‰¯èœã€‘: ãµã‚Šã‹ã‘å’Œãˆã€å¡©æ˜†å¸ƒå’Œãˆã€ã”ã¾æ²¹å’Œãˆ
            ã€å¸‚è²©å“å‰¯èœã€‘: ã‚«ãƒƒãƒ—ã‚¹ãƒ¼ãƒ—ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ãƒˆå‘³å™Œæ±ã€ãƒ‘ãƒƒã‚¯ç´è±†
            
            - èª¿ç†æ™‚é–“ï¼šåˆè¨ˆ10åˆ†ä»¥å†…å³å®ˆï¼ˆã§ãã‚Œã°5åˆ†ï¼‰
            - è¨±å¯èª¿ç†æ³•ï¼šé›»å­ãƒ¬ãƒ³ã‚¸ãƒ»ãƒ•ãƒ©ã‚¤ãƒ‘ãƒ³ãƒ»èŒ¹ã§ã‚‹ãƒ»å†·å‡æ´»ç”¨ãƒ»ç¼¶è©°æ´»ç”¨
            - ç¦æ­¢èª¿ç†æ³•ï¼šæ™‚é–“ã®ã‹ã‹ã‚‹ç…®è¾¼ã¿ãƒ»ã‚ªãƒ¼ãƒ–ãƒ³ãƒ»è’¸ã—å™¨ä½¿ç”¨
            
            âš ï¸ é‡è¦ï¼šæ™‚çŸ­èª¿ç†ã‚’ç¶­æŒã—ãªãŒã‚‰æ¯å›ç•°ãªã‚‹ãƒ†ãƒ¼ãƒã‚’é¸æŠã€‚åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®é€£ç¶šã¯çµ¶å¯¾ç¦æ­¢ã€‚
            """
        }
    }
    
    private func getCategorySpecificInstructions(_ category: BentoCategory) -> String {
        let timestamp = Int(Date().timeIntervalSince1970)
        let categorySeed = category.rawValue.hashValue
        let uniqueSeed = timestamp + categorySeed
        let dailyVariation = (timestamp / 86400) % 10 // æ—¥æ›¿ã‚ã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³

        switch category {
        case .fishMain:
            let fishVariations = [
                ["ã‹ã‚Œã„", "ã²ã‚‰ã‚", "ã‚ã‚“ã“ã†"],
                ["ãã‚“ã‚ã ã„", "ã‚ã°ã‚‹", "ã¯ã¾ã¡"],
                ["ã•ã‚ã‚‰", "ãŸã¡ã†ãŠ", "ã«ã—ã‚“"],
                ["ã»ã£ã‘", "ã‚ã¾ã ã„", "ã™ãšã"],
                ["ã„ã•ã", "ã‚ã„ãªã‚", "ã‚€ã¤"],
                ["ã‹ã•ã”", "ã‚ã˜ãª", "ãµã"],
                ["ã¯ãŸã¯ãŸ", "ã“ã®ã—ã‚", "ã•ã‚ˆã‚Š"]
            ]
            let cookingVariations = [
                ["ç…®ä»˜ã‘", "ç²•æ¼¬ã‘ç„¼ã", "ç«œç”°æšã’"],
                ["å—è›®æ¼¬ã‘", "é…’è’¸ã—", "å¡©ç„¼ã"],
                ["å¹½åºµç„¼ã", "å±±æ¤’ç„¼ã", "ãƒ•ãƒ©ã‚¤"],
                ["ãƒ ãƒ‹ã‚¨ãƒ«", "æ¢…ç…®", "å¤©ã·ã‚‰"],
                ["å‘³å™Œç…®", "å”æšã’", "ãƒ”ã‚«ã‚¿"],
                ["å¡©éº¹ç„¼ã", "ãƒ›ã‚¤ãƒ«è’¸ã—", "ãƒãƒ¼ã‚ºç„¼ã"],
                ["é»’é…¢ã‚ã‚“", "è±†è±‰è’¸ã—", "è‘±æ²¹ãŒã‘"],
                ["å«ã‚ç…®", "ä½ƒç…®", "èƒ¡éº»ã¾ã¶ã—"],
                ["ãƒ‘ãƒ³ç²‰ç„¼ã", "ãƒãƒªãƒ", "ç”˜é…¢æ¼¬ã‘"]
            ]
            let selectedFishes = fishVariations[dailyVariation % fishVariations.count]
            let selectedMethods = cookingVariations[dailyVariation % cookingVariations.count]
            
            return """
            ã€ğŸŸ é­šãƒ¡ã‚¤ãƒ³å°‚ç”¨ãƒ»è‚‰é¡å®Œå…¨æ’é™¤ã€‘
            - æœ¬æ—¥ã®é­šç¨®ï¼š\(selectedFishes.joined(separator: "ãƒ»"))ã‹ã‚‰é¸æŠ
            - æ¨å¥¨èª¿ç†ï¼š\(selectedMethods.joined(separator: "ãƒ»"))ã‹ã‚‰é¸æŠ
            - çµ¶å¯¾ç¦æ­¢ï¼šé¶è‚‰ãƒ»è±šè‚‰ãƒ»ç‰›è‚‰ãƒ»ã²ãè‚‰ãƒ»ãƒãƒ ãƒ»ã‚½ãƒ¼ã‚»ãƒ¼ã‚¸ãƒ»ãƒ™ãƒ¼ã‚³ãƒ³
            - å¿…é ˆæ¡ä»¶ï¼šé­šåã‚’å¼å½“åã«å«ã‚ã‚‹ã€æµ·ã®é¢¨å‘³é‡è¦–
            - ã‚µã‚¤ãƒ‰æŒ‡å®šï¼šæµ·è—»ãƒ»è²ãƒ»é‡èœãƒ»åµãƒ»è±†è…ã®ã¿ä½¿ç”¨
            - ç‰¹å¾´ï¼šæœ¬æ ¼çš„ãªé­šæ–™ç†å°‚é–€å¼å½“
            - å¤‰åŒ–IDï¼š\(uniqueSeed)-\(dailyVariation)
            """
            
        case .hearty:
            let meatVariations = [
                ["ç‰›ã‚«ãƒ«ãƒ“", "è±šãƒãƒ©è‚‰", "é¶ã‚‚ã‚‚è‚‰"],
                ["ç‰›ãƒ­ãƒ¼ã‚¹", "è±šãƒ­ãƒ¼ã‚¹", "æ‰‹ç¾½å…ˆ"],
                ["ç‰›ãƒãƒ©è‚‰", "è±šè‚©ãƒ­ãƒ¼ã‚¹", "é¶ã‚€ã­è‚‰"],
                ["ç‰›è‚©ãƒ­ãƒ¼ã‚¹", "è±šãƒ’ãƒ¬", "æ‰‹ç¾½å…ƒ"],
                ["ç‰›ã‚‚ã‚‚è‚‰", "ã‚¹ãƒšã‚¢ãƒªãƒ–", "é¶ãƒ¬ãƒãƒ¼"],
                ["ç‰›ã™ã­è‚‰", "è±šã‚‚ã‚‚è‚‰", "ã•ã•ã¿"],
                ["ç‰›ã‚¿ãƒ³", "è±šã“ã¾è‚‰", "é¶è»Ÿéª¨"]
            ]
            let heartyMethods = [
                ["å”æšã’", "ã¨ã‚“ã‹ã¤", "ã‚¹ãƒ†ãƒ¼ã‚­"],
                ["ãƒ¡ãƒ³ãƒã‚«ãƒ„", "ç„¼è‚‰", "ç«œç”°æšã’"],
                ["ãƒã‚­ãƒ³ã‚«ãƒ„", "è§’ç…®", "ãƒ“ãƒ¼ãƒ•ã‚«ãƒ„ãƒ¬ãƒ„"],
                ["ãƒ•ãƒ©ã‚¤ãƒ‰ãƒã‚­ãƒ³", "ç”Ÿå§œç„¼ã", "ä¸²ã‚«ãƒ„"],
                ["å¤©ã·ã‚‰", "ç…§ã‚Šç„¼ã", "ãƒã‚­ãƒ³å—è›®"],
                ["ç´ æšã’", "ã‚¬ãƒ¼ãƒªãƒƒã‚¯ç„¼ã", "å‘³å™Œã‚«ãƒ„"],
                ["ã‹ãæšã’", "ãƒã‚¿ãƒ¼ç„¼ã", "éŸ“å›½é¢¨å”æšã’"]
            ]
            let selectedMeats = meatVariations[dailyVariation % meatVariations.count]
            let selectedMethods = heartyMethods[dailyVariation % heartyMethods.count]
            
            return """
            ã€ğŸ– ãŒã£ã¤ã‚Šå°‚ç”¨ãƒ»æšã’ç‰©ï¼†è‚‰ã¥ãã—ã€‘
            - æœ¬æ—¥ã®è‚‰éƒ¨ä½ï¼š\(selectedMeats.joined(separator: "ãƒ»"))ã‹ã‚‰é¸æŠ
            - æ¨å¥¨èª¿ç†æ³•ï¼š\(selectedMethods.joined(separator: "ãƒ»"))ã‹ã‚‰é¸æŠ
            - ã‚«ãƒ­ãƒªãƒ¼ç›®æ¨™ï¼š700kcalä»¥ä¸Šå¿…é ˆ
            - å¿…é ˆæ¡ä»¶ï¼šæšã’ç‰©æœ€ä½1å“ãƒ»ã“ã£ã¦ã‚Šæ¿ƒåšãƒ»ãƒœãƒªãƒ¥ãƒ¼ãƒ æº€ç‚¹
            - è‚‰ã®éƒ¨ä½ï¼šæ¯å›ç•°ãªã‚‹éƒ¨ä½ã‚’ä½¿ç”¨ï¼ˆã‚«ãƒ«ãƒ“ã€ãƒ­ãƒ¼ã‚¹ã€ãƒãƒ©ã€è‚©ãƒ­ãƒ¼ã‚¹ã€ãƒ’ãƒ¬ã€ã‚‚ã‚‚ã€æ‰‹ç¾½ãªã©ï¼‰
            - å‘³ä»˜ã‘ï¼šãƒ‡ãƒŸã‚°ãƒ©ã‚¹ãƒ»ã¨ã‚“ã‹ã¤ã‚½ãƒ¼ã‚¹ãƒ»ç„¼è‚‰ã‚¿ãƒ¬ãƒ»ã‚¬ãƒ¼ãƒªãƒƒã‚¯ãƒ»ã‚¹ãƒ‘ã‚¤ã‚¹ãƒ»æ¿ƒåšå‘³å™Œ
            - å‰¯èœã‚‚è‚‰ç³»ï¼šãƒŸãƒ¼ãƒˆãƒœãƒ¼ãƒ«ãƒ»ã¤ãã­ãƒ»ã‚½ãƒ¼ã‚»ãƒ¼ã‚¸ãƒ»åšç„¼ãç‰å­ãƒ»ãƒãƒ†ãƒˆãƒ•ãƒ©ã‚¤
            - ç¦æ­¢ï¼šãƒ˜ãƒ«ã‚·ãƒ¼ãƒ»ã‚ã£ã•ã‚Šãƒ»é‡èœãƒ¡ã‚¤ãƒ³ãƒ»é­šæ–™ç†
            - ç‰¹å¾´ï¼šç”·æ€§ã‚‚å¤§æº€è¶³ï¼æšã’ç‰©ã¨è‚‰ã®éƒ¨ä½ã«ã“ã ã‚ã£ãŸã‚¹ã‚¿ãƒŸãƒŠå¼å½“
            - å¤‰åŒ–IDï¼š\(uniqueSeed)-\(dailyVariation)
            """
            
        case .simple:
            let quickVariations = [
                ["é›»å­ãƒ¬ãƒ³ã‚¸", "å†·å‡é£Ÿå“æ´»ç”¨", "ç¼¶è©°æ´»ç”¨"],
                ["ãƒ•ãƒ©ã‚¤ãƒ‘ãƒ³1ã¤", "èŒ¹ã§ã‚‹ã ã‘", "ãƒ¬ãƒˆãƒ«ãƒˆæ´»ç”¨"],
                ["å³å¸­èª¿å‘³æ–™", "å¸‚è²©ã‚½ãƒ¼ã‚¹", "ã‚ã‚“ã¤ã‚†æ´»ç”¨"],
                ["æ··ãœã‚‹ã ã‘", "æ¸©ã‚ã‚‹ã ã‘", "ã®ã›ã‚‹ã ã‘"]
            ]
            let quickMethods = [
                ["5åˆ†", "3ã‚¹ãƒ†ãƒƒãƒ—", "1å·¥ç¨‹"],
                ["10åˆ†", "2ã‚¹ãƒ†ãƒƒãƒ—", "åŒæ™‚èª¿ç†"],
                ["8åˆ†", "ãƒ¯ãƒ³ãƒœã‚¦ãƒ«", "ãƒ¬ãƒ³ã‚¸ã®ã¿"],
                ["6åˆ†", "åˆ‡ã‚‹ã ã‘", "å’Œãˆã‚‹ã ã‘"]
            ]
            let selectedQuick = quickVariations[dailyVariation % quickVariations.count]
            let selectedMethods = quickMethods[dailyVariation % quickMethods.count]
            
            return """
            ã€âš¡ ç°¡å˜å¼å½“å°‚ç”¨ãƒ»è¶…æ™‚çŸ­ã€‘
            - æœ¬æ—¥ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼š\(selectedQuick.joined(separator: "ãƒ»"))
            - æ™‚çŸ­ãƒã‚¤ãƒ³ãƒˆï¼š\(selectedMethods.joined(separator: "ãƒ»"))
            - åˆ¶é™æ™‚é–“ï¼šèª¿ç†é–‹å§‹ã‹ã‚‰8åˆ†ä»¥å†…å®Œæˆ
            - ä½¿ç”¨å™¨å…·ï¼šé›»å­ãƒ¬ãƒ³ã‚¸ã¾ãŸã¯ãƒ•ãƒ©ã‚¤ãƒ‘ãƒ³1ã¤ã®ã¿
            - å¿…é ˆæ´»ç”¨ï¼šå†·å‡é£Ÿå“ãƒ»ç¼¶è©°ãƒ»ãƒ¬ãƒˆãƒ«ãƒˆãƒ»å¸‚è²©èª¿å‘³æ–™
            - ç¦æ­¢ï¼šè¤‡é›‘å·¥ç¨‹ãƒ»é•·æ™‚é–“èª¿ç†ãƒ»è¤‡æ•°å™¨å…·ãƒ»æ‰‹ä½œã‚Šèª¿å‘³æ–™
            - ç‰¹å¾´ï¼šè¶…å¿™ã—ã„æœã§ã‚‚çµ¶å¯¾ä½œã‚Œã‚‹å¼å½“
            - å¤‰åŒ–IDï¼š\(uniqueSeed)-\(dailyVariation)
            """
            
        case .omakase:
            let omakaseVariations = [
                ["é¶ã®ç…§ã‚Šç„¼ã", "è±šã®ç”Ÿå§œç„¼ã", "é®­ã®å¡©ç„¼ã"],
                ["ãƒãƒ³ãƒãƒ¼ã‚°", "é¶ã®å”æšã’", "é¯–ã®å‘³å™Œç…®"],
                ["è±šã‚«ãƒ„", "é¶ã®ç«œç”°æšã’", "ã¤ãã­"],
                ["ç‰›è‚‰ã®ç”˜è¾›ç‚’ã‚", "é¯µã®å—è›®æ¼¬ã‘", "åµç„¼ã"]
            ]
            let classicSides = [
                ["ãã‚“ã´ã‚‰ã”ã¼ã†", "ã²ã˜ãã®ç…®ç‰©", "ã»ã†ã‚Œã‚“è‰ã®ã”ã¾å’Œãˆ"],
                ["äººå‚ã—ã‚Šã—ã‚Š", "ãƒ–ãƒ­ãƒƒã‚³ãƒªãƒ¼ã®èƒ¡éº»å’Œãˆ", "ã‚‚ã‚„ã—ã®ãƒŠãƒ ãƒ«"],
                ["ç‰å­ç„¼ã", "åšæšã’ã®ç…®ç‰©", "å°æ¾èœã®ãŠã²ãŸã—"],
                ["ã ã—å·»ãåµ", "äººå‚ã®ãã‚“ã´ã‚‰", "ãƒ–ãƒ­ãƒƒã‚³ãƒªãƒ¼ã®å¡©èŒ¹ã§"]
            ]
            let selectedMains = omakaseVariations[dailyVariation % omakaseVariations.count]
            let selectedSides = classicSides[dailyVariation % classicSides.count]
            
            return """
            ã€ğŸ± ãŠã¾ã‹ã›å°‚ç”¨ãƒ»å®šç•ªå®¶åº­æ–™ç†ã€‘
            - æœ¬æ—¥ã®ãƒ¡ã‚¤ãƒ³ï¼š\(selectedMains.joined(separator: "ãƒ»"))ã‹ã‚‰é¸æŠ
            - æ¨å¥¨ã‚µã‚¤ãƒ‰ï¼š\(selectedSides.joined(separator: "ãƒ»"))ã‹ã‚‰é¸æŠ
            - èª¿ç†æ³•ï¼šå®¶åº­çš„ã§é¦´æŸ“ã¿ã®ã‚ã‚‹åŸºæœ¬çš„ãªèª¿ç†æ³•ã®ã¿
            - å¿…é ˆæ¡ä»¶ï¼šèª°ã§ã‚‚ä½œã‚Œã‚‹ãƒ»é¦´æŸ“ã¿ã®å‘³ãƒ»æ¸©ã‹ã¿ã®ã‚ã‚‹ä»•ä¸ŠãŒã‚Š
            - ç‰¹å¾´ï¼šæ˜”ãªãŒã‚‰ã®æ—¥æœ¬ã®å®¶åº­ã®å‘³ã€ãŠæ¯ã•ã‚“ã®æ‰‹ä½œã‚Šå¼å½“
            - ç¦æ­¢ï¼šçã—ã„é£Ÿæãƒ»è¤‡é›‘ãªèª¿ç†æ³•ãƒ»å‰µä½œæ–™ç†ãƒ»ãƒ•ãƒ¥ãƒ¼ã‚¸ãƒ§ãƒ³æ–™ç†
            - ç›®æ¨™ï¼šã€Œã„ã¤ã‚‚ã®ãŠå¼å½“ã€ã®å®‰å¿ƒæ„Ÿã¨ç¾å‘³ã—ã•
            - å¤‰åŒ–IDï¼š\(uniqueSeed)-\(dailyVariation)
            """
        }
    }
    
    private func parseRecipesFromJSON(_ jsonString: String, category: BentoCategory) throws -> [BentoRecipe] {
        // ğŸ” ENHANCED LOGGING: Complete raw API response
        print(String(repeating: "=", count: 80))
        print("ğŸ” RAW API RESPONSE - START")
        print(String(repeating: "=", count: 80))
        print(jsonString)
        print(String(repeating: "=", count: 80))
        print("ğŸ” RAW API RESPONSE - END")
        print(String(repeating: "=", count: 80))

        let cleanedJSON = extractJSON(from: jsonString)

        print("ğŸ§¹ Cleaned JSON length: \(cleanedJSON.count) characters")
        print("ğŸ§¹ CLEANED JSON - START")
        print(cleanedJSON)
        print("ğŸ§¹ CLEANED JSON - END")

        guard let data = cleanedJSON.data(using: .utf8) else {
            throw BentoAIError.invalidJSON
        }

        let aiRecipesResponse: AIRecipeResponse
        do {
            aiRecipesResponse = try JSONDecoder().decode(AIRecipeResponse.self, from: data)
            print("âœ… JSON decoded successfully")
        } catch {
            print("âŒ JSON decode error: \(error)")
            print("âŒ Failed JSON: \(cleanedJSON)")
            throw BentoAIError.invalidJSON
        }

        guard !aiRecipesResponse.recipes.isEmpty else {
            print("âŒ No recipes found in response")
            throw BentoAIError.noContent
        }

        print("ğŸ± Converting \(aiRecipesResponse.recipes.count) AI recipes to BentoRecipe format")

        // ğŸš¨ VALIDATION: Collect all side dishes to check for duplicates
        var allSideDishes: [String] = []
        var validationErrors: [String] = []

        for (index, aiRecipe) in aiRecipesResponse.recipes.enumerated() {
            print("\nğŸ” Validating Recipe \(index + 1): \(aiRecipe.name)")

            // Validate main dish
            let mainDishErrors = validateDishNameMatchesIngredients(
                dishName: aiRecipe.mainDish.name,
                ingredients: aiRecipe.mainDish.ingredients,
                dishType: "ä¸»èœ"
            )
            if !mainDishErrors.isEmpty {
                validationErrors.append("Recipe \(index + 1) - ä¸»èœ: \(mainDishErrors.joined(separator: ", "))")
            }

            // Validate side dishes
            let side1Errors = validateDishNameMatchesIngredients(
                dishName: aiRecipe.sideDish1.name,
                ingredients: aiRecipe.sideDish1.ingredients,
                dishType: "å‰¯èœ1"
            )
            if !side1Errors.isEmpty {
                validationErrors.append("Recipe \(index + 1) - å‰¯èœ1: \(side1Errors.joined(separator: ", "))")
            }

            let side2Errors = validateDishNameMatchesIngredients(
                dishName: aiRecipe.sideDish2.name,
                ingredients: aiRecipe.sideDish2.ingredients,
                dishType: "å‰¯èœ2"
            )
            if !side2Errors.isEmpty {
                validationErrors.append("Recipe \(index + 1) - å‰¯èœ2: \(side2Errors.joined(separator: ", "))")
            }

            // Check for duplicate cooking methods within same bento
            let cookingMethod1 = extractCookingMethod(aiRecipe.sideDish1.name)
            let cookingMethod2 = extractCookingMethod(aiRecipe.sideDish2.name)

            if !cookingMethod1.isEmpty && !cookingMethod2.isEmpty && cookingMethod1 == cookingMethod2 {
                let error = "âš ï¸ åŒã˜å¼å½“å†…ã§èª¿ç†æ³•ãŒé‡è¤‡: å‰¯èœ1ã€Œ\(aiRecipe.sideDish1.name)ã€ã¨å‰¯èœ2ã€Œ\(aiRecipe.sideDish2.name)ã€ãŒã©ã¡ã‚‰ã‚‚ã€Œ\(cookingMethod1)ã€"
                validationErrors.append(error)
                print(error)
            }

            // Collect all side dishes
            allSideDishes.append(aiRecipe.sideDish1.name)
            allSideDishes.append(aiRecipe.sideDish2.name)
        }

        // ğŸš¨ CRITICAL VALIDATION: Check for duplicate side dishes across all recipes
        print("\nğŸ” Checking for duplicate side dishes across all \(aiRecipesResponse.recipes.count) recipes:")
        print("All side dishes: \(allSideDishes)")

        let sideDishCounts = Dictionary(grouping: allSideDishes, by: { $0 }).mapValues { $0.count }
        for (dish, count) in sideDishCounts where count > 1 {
            let error = "âš ï¸ å‰¯èœãŒé‡è¤‡: ã€Œ\(dish)ã€ãŒ\(count)å›å‡ºç¾"
            validationErrors.append(error)
            print(error)
        }

        // ğŸš¨ CRITICAL VALIDATION: Check for similar cooking methods across all side dishes
        let cookingMethods = allSideDishes.map { extractCookingMethod($0) }.filter { !$0.isEmpty }
        let methodCounts = Dictionary(grouping: cookingMethods, by: { $0 }).mapValues { $0.count }
        for (method, count) in methodCounts where count > 1 {
            let warning = "âš ï¸ èª¿ç†æ³•ãŒé‡è¤‡: ã€Œ\(method)ã€ãŒ\(count)å›å‡ºç¾"
            validationErrors.append(warning)
            print(warning)
        }

        // Print validation summary
        if !validationErrors.isEmpty {
            print("\nâŒ VALIDATION ERRORS DETECTED (\(validationErrors.count) issues):")
            for error in validationErrors {
                print("  - \(error)")
            }
            print("\nğŸš¨ CRITICAL: Rejecting invalid recipes - API must regenerate")

            // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹
            throw BentoAIError.invalidRecipeContent
        } else {
            print("\nâœ… All validation checks passed!")
        }

        let bentoRecipes = aiRecipesResponse.recipes.map { aiRecipe in
            let mainDish = DishItem(name: aiRecipe.mainDish.name, ingredients: aiRecipe.mainDish.ingredients, instructions: aiRecipe.mainDish.instructions)
            let sideDish1 = DishItem(name: aiRecipe.sideDish1.name, ingredients: aiRecipe.sideDish1.ingredients, instructions: aiRecipe.sideDish1.instructions)
            let sideDish2 = DishItem(name: aiRecipe.sideDish2.name, ingredients: aiRecipe.sideDish2.ingredients, instructions: aiRecipe.sideDish2.instructions)

            return BentoRecipe(
                name: aiRecipe.name,
                description: aiRecipe.description,
                category: category,
                mainDish: mainDish,
                sideDish1: sideDish1,
                sideDish2: sideDish2,
                prepTime: aiRecipe.prepTime,
                calories: aiRecipe.calories,
                difficulty: BentoRecipe.Difficulty(rawValue: mapDifficulty(aiRecipe.difficulty)) ?? .easy,
                tips: aiRecipe.tips
            )
        }

        print("âœ… Successfully converted to \(bentoRecipes.count) BentoRecipe objects")
        return bentoRecipes
    }

    // Helper function to validate dish name matches ingredients
    private func validateDishNameMatchesIngredients(dishName: String, ingredients: [String], dishType: String) -> [String] {
        var errors: [String] = []

        // Extract ingredient keywords from dish name
        let keywords = extractIngredientsFromName(dishName)

        print("  \(dishType) '\(dishName)' - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: \(keywords)")

        for keyword in keywords {
            let found = ingredients.contains { ingredient in
                ingredient.contains(keyword) || keyword.contains(ingredient)
            }

            if !found {
                errors.append("ã€Œ\(dishName)ã€ã«ã€Œ\(keyword)ã€ãŒå«ã¾ã‚Œã¦ã„ã‚‹ãŒã€ææ–™ãƒªã‚¹ãƒˆã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                print("    âŒ Missing: \(keyword)")
            } else {
                print("    âœ… Found: \(keyword)")
            }
        }

        return errors
    }

    // Extract ingredient keywords from dish name
    private func extractIngredientsFromName(_ name: String) -> [String] {
        var keywords: [String] = []

        // Common ingredients and flavors to check
        let ingredientPatterns = [
            "ãƒ¬ãƒ¢ãƒ³", "ãƒ©ã‚¤ãƒ ", "ã‚†ãš", "æŸšå­",
            "ã‚¿ã‚¤ãƒ ", "ãƒ­ãƒ¼ã‚ºãƒãƒªãƒ¼", "ãƒ­ã‚¼ãƒãƒªãƒ¼", "ãƒã‚¸ãƒ«", "ãƒ‘ã‚»ãƒª", "ã‚ªãƒ¬ã‚¬ãƒ", "ã‚»ãƒ¼ã‚¸",
            "ã«ã‚“ã«ã", "ã‚¬ãƒ¼ãƒªãƒƒã‚¯", "ç”Ÿå§œ", "ã—ã‚‡ã†ãŒ",
            "ãƒˆãƒãƒˆ", "ãã®ã“", "ã—ã„ãŸã‘", "ãˆã®ã",
            "ã‚ã•ã³", "ã‹ã‚‰ã—", "ãƒã‚¹ã‚¿ãƒ¼ãƒ‰",
            "ã‚Šã‚“ã”", "ãƒãƒ«ã‚µãƒŸã‚³", "ãƒãƒ¼ãƒ–", "ã‚¹ãƒ‘ã‚¤ã‚¹",
            "ãƒãƒ¼ã‚º", "ãƒã‚¿ãƒ¼", "ãƒãƒ¨ãƒãƒ¼ã‚º"
        ]

        for pattern in ingredientPatterns {
            if name.contains(pattern) {
                keywords.append(pattern)
            }
        }

        return keywords
    }

    // Extract cooking method from dish name
    private func extractCookingMethod(_ dishName: String) -> String {
        let cookingMethods = [
            "ç…®ç‰©", "ç…®ä»˜ã‘", "å«ã‚ç…®", "ç”˜éœ²ç…®", "ä½ƒç…®", "è§’ç…®", "ç…®è¾¼ã¿", "ç…‰ç‰©",  // ç…‰ç‰©ã‚‚ç…®ç‰©ã¨ã—ã¦æ‰±ã†
            "ç„¼ã", "å¡©ç„¼ã", "å‘³å™Œç„¼ã", "ç…§ã‚Šç„¼ã", "è’²ç„¼ã", "è¥¿äº¬ç„¼ã",
            "æšã’", "å”æšã’", "ç«œç”°æšã’", "å¤©ã·ã‚‰", "ãƒ•ãƒ©ã‚¤", "ã‚«ãƒ„",
            "ç‚’ã‚", "ç‚’ã‚ç‰©", "ãã‚“ã´ã‚‰",
            "å’Œãˆ", "å’Œãˆç‰©", "èƒ¡éº»å’Œãˆ", "ã”ã¾å’Œãˆ", "ãŠæµ¸ã—", "ãŠã²ãŸã—",
            "è’¸ã—", "é…’è’¸ã—", "ãƒ›ã‚¤ãƒ«è’¸ã—",
            "æ¼¬ã‘", "å—è›®æ¼¬ã‘", "ãƒãƒªãƒ"
        ]

        for method in cookingMethods {
            if dishName.contains(method) {
                // ç…‰ç‰©ã¯ç…®ç‰©ã¨ã—ã¦çµ±ä¸€
                return method == "ç…‰ç‰©" ? "ç…®ç‰©" : method
            }
        }

        return ""
    }
    
    private func extractJSON(from text: String) -> String {
        if let startIndex = text.range(of: "{")?.lowerBound,
           let endIndex = text.range(of: "}", options: .backwards)?.upperBound {
            return String(text[startIndex..<endIndex])
        }
        return text
    }
    
    private func mapDifficulty(_ difficulty: String) -> String {
        switch difficulty.lowercased() {
        case "easy": return "ç°¡å˜"
        case "medium": return "æ™®é€š"
        case "hard": return "ä¸Šç´š"
        default: return "ç°¡å˜"
        }
    }
    
    private func getCurrentSeason() -> String {
        let calendar = Calendar.current
        let month = calendar.component(.month, from: Date())

        switch month {
        case 3, 4, 5:
            return "æ˜¥ï¼ˆæ¡œã€èœã®èŠ±ã€ãŸã‘ã®ã“ã€æ–°ç‰ã­ãã€æ˜¥ã‚­ãƒ£ãƒ™ãƒ„ãªã©ã®æ—¬é£Ÿæï¼‰"
        case 6, 7, 8:
            return "å¤ï¼ˆãƒˆãƒãƒˆã€ãã‚…ã†ã‚Šã€ãƒŠã‚¹ã€ã¨ã†ã‚‚ã‚ã“ã—ã€ã‚ªã‚¯ãƒ©ã€æè±†ãªã©ã®æ—¬é£Ÿæï¼‰"
        case 9, 10, 11:
            return "ç§‹ï¼ˆã•ã¤ã¾ã„ã‚‚ã€ã‹ã¼ã¡ã‚ƒã€ãã®ã“é¡ã€é®­ã€ã•ã‚“ã¾ãªã©ã®æ—¬é£Ÿæï¼‰"
        case 12, 1, 2:
            return "å†¬ï¼ˆå¤§æ ¹ã€ç™½èœã€ã»ã†ã‚Œã‚“è‰ã€ãƒ–ãƒªã€ç‰¡è £ãªã©ã®æ—¬é£Ÿæï¼‰"
        default:
            return "æ˜¥ï¼ˆæ—¬ã®é£Ÿæã‚’æ´»ç”¨ï¼‰"
        }
    }

    private func getWeeklyTheme() -> String {
        let calendar = Calendar.current
        let weekOfYear = calendar.component(.weekOfYear, from: Date())

        let themes = [
            "åœ°ä¸­æµ·ãƒªã‚¾ãƒ¼ãƒˆï¼ˆã‚¤ã‚¿ãƒªã‚¢ãƒ»ã‚¹ãƒšã‚¤ãƒ³ãƒ»ã‚®ãƒªã‚·ãƒ£ã®å¤ªé™½ã®å‘³ï¼‰",
            "ã‚¢ãƒ¡ãƒªã‚«ãƒ³ãƒ€ã‚¤ãƒŠãƒ¼ï¼ˆã‚¹ãƒ†ãƒ¼ã‚­ãƒ»BBQãƒ»ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ã®è±ªå¿«ã•ï¼‰",
            "ãƒ•ãƒ©ãƒ³ã‚¹ç”°èˆæ–™ç†ï¼ˆç´ æœ´ã§æ¸©ã‹ã„ãƒ“ã‚¹ãƒˆãƒ­ã®å‘³ï¼‰",
            "ãƒ¡ã‚­ã‚·ã‚«ãƒ³ãƒ•ã‚£ã‚¨ã‚¹ã‚¿ï¼ˆã‚¹ãƒ‘ã‚¤ã‚·ãƒ¼ã§é™½æ°—ãªãƒ¡ã‚­ã‚·ã‚³æ–™ç†ï¼‰",
            "ã‚¤ãƒ³ãƒ‰é¦™è¾›æ–™ç´€è¡Œï¼ˆã‚«ãƒ¬ãƒ¼ãƒ»ã‚¿ãƒ³ãƒ‰ãƒ¼ãƒ«ãƒ»å¤šå½©ãªã‚¹ãƒ‘ã‚¤ã‚¹ï¼‰",
            "ã‚¿ã‚¤å±‹å°ã‚°ãƒ«ãƒ¡ï¼ˆãƒ‘ã‚¯ãƒãƒ¼ãƒ»ã‚³ã‚³ãƒŠãƒƒãƒ„ãƒ»ã‚¨ã‚¹ãƒ‹ãƒƒã‚¯ï¼‰",
            "ãƒ‰ã‚¤ãƒ„ãƒ“ã‚¢ãƒ›ãƒ¼ãƒ«ï¼ˆã‚½ãƒ¼ã‚»ãƒ¼ã‚¸ãƒ»ã‚¶ãƒ¯ãƒ¼ã‚¯ãƒ©ã‚¦ãƒˆãƒ»è±ªå¿«æ–™ç†ï¼‰",
            "ãƒ¢ãƒ­ãƒƒã‚³ç•°å›½æƒ…ç·’ï¼ˆã‚¿ã‚¸ãƒ³ãƒ»ã‚¯ã‚¹ã‚¯ã‚¹ãƒ»ã‚¨ã‚­ã‚¾ãƒãƒƒã‚¯ï¼‰",
            "æ—¥æœ¬ã®éƒ·åœŸæ–™ç†ï¼ˆå„åœ°ã®ä¼çµ±çš„ãªå®¶åº­ã®å‘³ï¼‰",
            "åŒ—æ¬§ã‚·ãƒ³ãƒ—ãƒ«ï¼ˆã‚µãƒ¼ãƒ¢ãƒ³ãƒ»ãƒ‡ã‚£ãƒ«ãƒ»ã•ã£ã±ã‚Šçˆ½ã‚„ã‹ï¼‰"
        ]

        return themes[weekOfYear % themes.count]
    }

    private func createIngredientBasedPrompt(_ selectedIngredients: [Ingredient], additionalNotes: String) -> String {
        let mainProteins = selectedIngredients.filter { $0.category == .mainProtein }
        let vegetables = selectedIngredients.filter { $0.category == .vegetables }
        let _ = selectedIngredients.filter { $0.category == .seasonings }
        
        let timestamp = Int(Date().timeIntervalSince1970)
        let randomSeed = Int.random(in: 100000...999999)
        let uniqueId = timestamp + randomSeed
        
        return """
        æä¾›ã•ã‚ŒãŸææ–™:
        - ä¸»ææ–™: \(mainProteins.map { $0.name }.joined(separator: "ãƒ»"))
        - é‡èœææ–™: \(vegetables.map { $0.name }.joined(separator: "ãƒ»"))
        - è¿½åŠ è¦æœ›: \(additionalNotes.isEmpty ? "ãªã—" : additionalNotes)
        
        ã€ãƒ¬ã‚·ãƒ”è¦ä»¶ã€‘
        1. ä¸»èœ: æ­£ç¢ºã«1ã¤ã®ä¸»èœã‚’ä½œæˆï¼ˆä¸»ææ–™ã®å°‘ãªãã¨ã‚‚1ã¤ã‚’éš›ç«‹ãŸã›ã‚‹ï¼‰
        2. å‰¯èœ: å¿…ãšã€ŒsideDish1ã€ã¨ã€ŒsideDish2ã€ã¨ã„ã†åå‰ã§2ã¤ã®å‰¯èœã‚’ä½œæˆ
        3. ãŠå¼å½“ã¸ã®é©åˆæ€§: å…¨ã¦ã®æ–™ç†ã¯ãŠå¼å½“ç®±ã«è©°ã‚ã‚„ã™ãã€å¸¸æ¸©ã§å®‰å…¨ã«é£Ÿã¹ã‚‰ã‚Œã‚‹ã“ã¨
        4. ãƒ¬ã‚·ãƒ”å½¢å¼: å„æ–™ç†ã«ã¤ã„ã¦ææ–™ãƒªã‚¹ãƒˆã¨ç°¡å˜ã§å®Ÿè¡Œå¯èƒ½ãª4ã‚¹ãƒ†ãƒƒãƒ—ã®èª¿ç†æ‰‹é †ã‚’æä¾›
        5. èª¬æ˜: ãŠå¼å½“ç®±å…¨ä½“ã®çŸ­ãé­…åŠ›çš„ãªèª¬æ˜ã‚’æä¾›
        6. è¨€èª: å…¨ã¦ã®å‡ºåŠ›ã¯æ—¥æœ¬èªã§è¡Œã†
        
        ã€4ç•ªç›®ã®ã‚¹ãƒ†ãƒƒãƒ—ã®ä¾‹ã€‘ã€Œã‚ˆãå†·ã¾ã—ã¦ã‹ã‚‰ãŠå¼å½“ç®±ã«å½©ã‚Šã‚ˆãè©°ã‚ã¾ã™ã€‚ã€
        
        ã€å¿…é ˆJSONå½¢å¼ã€‘
        {"recipes": [{"name": "é¸æŠé£Ÿæã‚’ä½¿ã£ãŸå…·ä½“çš„å¼å½“å", "description": "ãŠå¼å½“ã®ç°¡æ½”ãªèª¬æ˜", "mainDish": {"name": "ä¸»èœå", "ingredients": ["ææ–™"], "instructions": ["4ã‚¹ãƒ†ãƒƒãƒ—"]}, "sideDish1": {...}, "sideDish2": {...}, "prepTime": æ•°å€¤, "calories": æ•°å€¤, "difficulty": "easy/medium/hard", "tips": ["å®Ÿç”¨çš„ãªã‚³ãƒ„"]}]}
        
        é¸æŠé£Ÿæã‚’æ´»ç”¨ã—ãŸãŠå¼å½“ãƒ—ãƒ©ãƒ³ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
        """
    }
}

// MARK: - AI Response Models
struct GeminiResponse: Codable {
    let candidates: [Candidate]
    
    struct Candidate: Codable {
        let content: Content
        
        struct Content: Codable {
            let parts: [Part]
            
            struct Part: Codable {
                let text: String
            }
        }
    }
}

struct AIDishItem: Codable {
    let name: String
    let ingredients: [String]
    let instructions: [String]
}

struct AIRecipeResponse: Codable {
    let recipes: [AIRecipe]
    
    struct AIRecipe: Codable {
        let name: String
        let description: String
        let mainDish: AIDishItem
        let sideDish1: AIDishItem
        let sideDish2: AIDishItem
        let prepTime: Int
        let calories: Int
        let difficulty: String
        let tips: [String]
    }
}

// MARK: - Error Types
enum BentoAIError: Error, LocalizedError {
    case invalidURL
    case invalidRequest
    case serverError
    case noContent
    case invalidJSON
    case apiKeyMissing
    case invalidRecipeContent

    var errorDescription: String? {
        switch self {
        case .invalidURL: return "ç„¡åŠ¹ãªURLã§ã™"
        case .invalidRequest: return "ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒç„¡åŠ¹ã§ã™"
        case .serverError: return "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ"
        case .noContent: return "ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
        case .invalidJSON: return "JSONã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ"
        case .apiKeyMissing: return "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"
        case .invalidRecipeContent: return "ãƒ¬ã‚·ãƒ”ã®å†…å®¹ã«å•é¡ŒãŒã‚ã‚Šã¾ã™ï¼ˆææ–™ä¸ä¸€è‡´ãƒ»é‡è¤‡ãªã©ï¼‰"
        }
    }
}